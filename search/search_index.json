{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Candles Feed Framework","text":"<p>Welcome to the Candles Feed documentation! This framework provides a modular, plugin-based approach to fetching and managing candlestick data from various cryptocurrency exchanges.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Pluggable Architecture: Add support for new exchanges without modifying core code</li> <li>Multiple Network Strategies: Support for both WebSocket and REST API-based data collection</li> <li>Robust Data Handling: Data validation, sanitization, and standardization</li> <li>Type Safety: Strong typing throughout the codebase with Python 3.12 features</li> <li>Easy to Extend: Clear interfaces and separation of concerns</li> <li>Performance Optimized: Memory-efficient data structures and processing</li> <li>Modern Python: Leverages latest Python features and best practices</li> <li>Comprehensive Testing Resources: Mock servers and simulation tools for development and testing</li> </ul>"},{"location":"#framework-overview","title":"Framework Overview","text":"<pre><code>graph LR\n    Client[Client Application] --&gt; CandlesFeed\n    CandlesFeed --&gt; ExchangeAdapter\n\n    subgraph \"Core Components\"\n        CandlesFeed\n        NetworkStrategy\n        DataProcessor\n        ExchangeRegistry\n    end\n\n    subgraph \"Exchange Adapters\"\n        ExchangeAdapter\n        BinanceAdapter\n        CoinbaseAdapter\n        KrakenAdapter\n        KuCoinAdapter\n        OKXAdapter\n        BybitAdapter\n        NewExchangeAdapter[New Exchange...]\n    end\n\n    ExchangeRegistry --&gt; ExchangeAdapter\n    CandlesFeed --&gt; NetworkStrategy\n    CandlesFeed --&gt; DataProcessor\n\n    class NewExchangeAdapter fill:#f96;</code></pre>"},{"location":"#supported-exchanges","title":"Supported Exchanges","text":"<ul> <li>Binance (Spot and Perpetual)</li> <li>Bybit (Spot and Perpetual)</li> <li>Coinbase Advanced Trade</li> <li>Kraken Spot</li> <li>KuCoin (Spot and Perpetual)</li> <li>OKX (Spot and Perpetual)</li> <li>Gate.io (Spot and Perpetual)</li> <li>Hyperliquid (Perpetual)</li> <li>MEXC (Spot and Perpetual)</li> <li>AscendEX (Spot)</li> </ul>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<p>This documentation is organized into the following sections:</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation: How to install and set up the framework</li> <li>Quick Start: Simple examples to get you started</li> <li>Architecture: Understanding the framework design</li> </ul>"},{"location":"#adapters","title":"Adapters","text":"<ul> <li>Overview: Introduction to exchange adapters</li> <li>Implementation: How to implement a new adapter</li> <li>REST API: Working with REST endpoints</li> <li>WebSocket: Real-time data with WebSockets</li> <li>Testing: Testing your adapter implementation</li> </ul>"},{"location":"#testing-resources","title":"Testing Resources","text":"<ul> <li>Overview: Introduction to testing tools</li> <li>Mock Server: Simulate exchange APIs</li> <li>Exchange Simulation: Testing without real exchanges</li> </ul>"},{"location":"#examples","title":"Examples","text":"<ul> <li>Simple Usage: Basic usage patterns</li> <li>Binance Spot Example: Working with Binance</li> <li>Mock Server Example: Using testing resources</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Core Components: Reference for core framework classes</li> <li>Adapters: Exchange adapter interfaces</li> <li>Utilities: Helper functions and utilities</li> </ul>"},{"location":"#development-guide","title":"Development Guide","text":"<ul> <li>Contributing: How to contribute to the project</li> <li>Coding Standards: Code style guidelines</li> <li>Testing Guide: Writing effective tests</li> </ul>"},{"location":"#for-developers","title":"For Developers","text":"<p>If you want to contribute to the framework or add support for a new exchange, see the Adding New Exchange section and the Development Guide.</p>"},{"location":"#compatibility-notes","title":"Compatibility Notes","text":"<p>This package supports Python 3.12+ and leverages modern Python features such as: - Type Protocol definitions - Advanced data validation - Concurrency with asyncio - Type hints throughout the codebase</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache License 2.0 - see the LICENSE file for details.</p>"},{"location":"adapters/implementation/","title":"Adapter Implementation Guide","text":"<p>This guide walks you through the process of implementing an adapter for a new exchange.</p>"},{"location":"adapters/implementation/#step-1-set-up-directory-structure","title":"Step 1: Set Up Directory Structure","text":"<p>First, create the necessary directory structure:</p> <pre><code>mkdir -p candles_feed/adapters/your_exchange_name\n</code></pre>"},{"location":"adapters/implementation/#step-2-create-constants-file","title":"Step 2: Create Constants File","text":"<p>Create a constants file to define exchange-specific values:</p> <pre><code># candles_feed/adapters/your_exchange_name/constants.py\n\nfrom typing import Dict\n\n# API URLs\nREST_URL = \"https://api.your-exchange.com\"\nWSS_URL = \"wss://ws.your-exchange.com\"\n\n# API endpoints\nCANDLES_ENDPOINT = \"/api/v1/klines\"\nSERVER_TIME_ENDPOINT = \"/api/v1/time\"\n\n# API rate limits\nMAX_RESULTS_PER_CANDLESTICK_REST_REQUEST = 1000\n\n# Intervals mapping: interval name -&gt; seconds\nINTERVALS: Dict[str, int] = {\n    \"1m\": 60,\n    \"5m\": 300,\n    \"15m\": 900,\n    \"1h\": 3600,\n    \"4h\": 14400,\n    \"1d\": 86400,\n    \"1w\": 604800\n}\n\n# Exchange-specific interval formats (if needed)\nINTERVAL_TO_EXCHANGE_FORMAT = {\n    \"1m\": \"1min\",\n    \"5m\": \"5min\",\n    \"15m\": \"15min\",\n    \"1h\": \"1hour\",\n    \"4h\": \"4hour\",\n    \"1d\": \"1day\",\n    \"1w\": \"1week\"\n}\n\n# Websocket supported intervals\nWS_INTERVALS = [\"1m\", \"5m\", \"15m\", \"1h\"]  # Not all exchanges support all intervals via WebSocket\n</code></pre>"},{"location":"adapters/implementation/#step-3-implement-the-adapter-class","title":"Step 3: Implement the Adapter Class","text":"<p>Create the adapter class that inherits from <code>BaseAdapter</code>:</p> <pre><code># candles_feed/adapters/your_exchange_name/your_exchange_adapter.py\n\nfrom typing import Dict, List, Optional\n\nfrom candles_feed.adapters.base_adapter import BaseAdapter\nfrom candles_feed.adapters.your_exchange_name.constants import (\n    INTERVALS, REST_URL, WSS_URL, WS_INTERVALS, CANDLES_ENDPOINT,\n    MAX_RESULTS_PER_CANDLESTICK_REST_REQUEST, INTERVAL_TO_EXCHANGE_FORMAT\n)\nfrom candles_feed.core.candle_data import CandleData\nfrom candles_feed.core.exchange_registry import ExchangeRegistry\n\n\n@ExchangeRegistry.register(\"your_exchange_name\")\nclass YourExchangeAdapter(BaseAdapter):\n    \"\"\"Your exchange adapter implementation.\"\"\"\n\n    def get_trading_pair_format(self, trading_pair: str) -&gt; str:\n        \"\"\"Convert standard trading pair format to exchange format.\n\n        Args:\n            trading_pair: Trading pair in standard format (e.g., \"BTC-USDT\")\n\n        Returns:\n            Trading pair in exchange format\n        \"\"\"\n        # Implement exchange-specific trading pair formatting\n        # For example, some exchanges use format like \"BTCUSDT\" without hyphen\n        return trading_pair.replace(\"-\", \"\")\n\n    def get_rest_url(self) -&gt; str:\n        \"\"\"Get REST API URL for candles.\n\n        Returns:\n            REST API URL\n        \"\"\"\n        return f\"{REST_URL}{CANDLES_ENDPOINT}\"\n\n    def get_ws_url(self) -&gt; str:\n        \"\"\"Get WebSocket URL.\n\n        Returns:\n            WebSocket URL\n        \"\"\"\n        return WSS_URL\n\n    def get_rest_params(self, \n                      trading_pair: str, \n                      interval: str, \n                      start_time: Optional[int] = None, \n                      end_time: Optional[int] = None, \n                      limit: Optional[int] = MAX_RESULTS_PER_CANDLESTICK_REST_REQUEST) -&gt; dict:\n        \"\"\"Get parameters for REST API request.\n\n        Args:\n            trading_pair: Trading pair\n            interval: Candle interval\n            start_time: Start time in seconds\n            end_time: End time in seconds\n            limit: Maximum number of candles to return\n\n        Returns:\n            Dictionary of parameters for REST API request\n        \"\"\"\n        # Implement exchange-specific REST parameters\n        params = {\n            \"symbol\": self.get_trading_pair_format(trading_pair),\n            \"interval\": INTERVAL_TO_EXCHANGE_FORMAT.get(interval, interval),\n            \"limit\": limit\n        }\n\n        # Some exchanges use different parameter names or formats for timestamps\n        if start_time:\n            params[\"startTime\"] = start_time * 1000  # Convert to milliseconds if needed\n\n        if end_time:\n            params[\"endTime\"] = end_time * 1000  # Convert to milliseconds if needed\n\n        return params\n\n    def parse_rest_response(self, data: dict) -&gt; List[CandleData]:\n        \"\"\"Parse REST API response into CandleData objects.\n\n        Args:\n            data: REST API response\n\n        Returns:\n            List of CandleData objects\n        \"\"\"\n        # Implement exchange-specific response parsing\n        candles = []\n\n        # Example implementation (adjust according to exchange response format)\n        for row in data.get(\"data\", []):\n            candles.append(CandleData(\n                timestamp_raw=row[0],  # Timestamp (adjust format as needed)\n                open=float(row[1]),    # Open price\n                high=float(row[2]),    # High price\n                low=float(row[3]),     # Low price\n                close=float(row[4]),   # Close price\n                volume=float(row[5]),  # Volume\n                # Optional fields (set to 0 if not provided)\n                quote_asset_volume=float(row[6]) if len(row) &gt; 6 else 0.0,\n                n_trades=int(row[7]) if len(row) &gt; 7 else 0,\n                taker_buy_base_volume=float(row[8]) if len(row) &gt; 8 else 0.0,\n                taker_buy_quote_volume=float(row[9]) if len(row) &gt; 9 else 0.0\n            ))\n\n        return candles\n\n    def get_ws_subscription_payload(self, trading_pair: str, interval: str) -&gt; dict:\n        \"\"\"Get WebSocket subscription payload.\n\n        Args:\n            trading_pair: Trading pair\n            interval: Candle interval\n\n        Returns:\n            WebSocket subscription payload\n        \"\"\"\n        # Implement exchange-specific WebSocket subscription payload\n        # Example implementation (adjust according to exchange format)\n        return {\n            \"method\": \"subscribe\",\n            \"params\": [\n                f\"kline_{interval}_{self.get_trading_pair_format(trading_pair)}\"\n            ],\n            \"id\": 1\n        }\n\n    def parse_ws_message(self, data: dict) -&gt; Optional[List[CandleData]]:\n        \"\"\"Parse WebSocket message into CandleData objects.\n\n        Args:\n            data: WebSocket message\n\n        Returns:\n            List of CandleData objects or None if message is not a candle update\n        \"\"\"\n        # Implement exchange-specific WebSocket message parsing\n        # Example implementation (adjust according to exchange message format)\n        if \"data\" in data and \"k\" in data.get(\"data\", {}):\n            k = data[\"data\"][\"k\"]\n            return [CandleData(\n                timestamp_raw=k[\"t\"],  # Timestamp (adjust format as needed)\n                open=float(k[\"o\"]),    # Open price\n                high=float(k[\"h\"]),    # High price\n                low=float(k[\"l\"]),     # Low price\n                close=float(k[\"c\"]),   # Close price\n                volume=float(k[\"v\"]),  # Volume\n                # Optional fields (set to 0 if not provided)\n                quote_asset_volume=float(k.get(\"q\", 0)),\n                n_trades=int(k.get(\"n\", 0)),\n                taker_buy_base_volume=float(k.get(\"V\", 0)),\n                taker_buy_quote_volume=float(k.get(\"Q\", 0))\n            )]\n\n        return None\n\n    def get_supported_intervals(self) -&gt; Dict[str, int]:\n        \"\"\"Get supported intervals and their durations in seconds.\n\n        Returns:\n            Dictionary mapping interval strings to their duration in seconds\n        \"\"\"\n        return INTERVALS\n\n    def get_ws_supported_intervals(self) -&gt; List[str]:\n        \"\"\"Get intervals supported by WebSocket API.\n\n        Returns:\n            List of interval strings supported by WebSocket API\n        \"\"\"\n        return WS_INTERVALS\n</code></pre>"},{"location":"adapters/implementation/#step-4-create-the-init-file","title":"Step 4: Create the Init File","text":"<p>Create an <code>__init__.py</code> file to expose your adapter:</p> <pre><code># candles_feed/adapters/your_exchange_name/__init__.py\n\nfrom candles_feed.adapters.your_exchange_name.your_exchange_adapter import YourExchangeAdapter\n\n__all__ = [\"YourExchangeAdapter\"]\n</code></pre>"},{"location":"adapters/implementation/#step-5-update-the-adapters-init-file","title":"Step 5: Update the Adapters Init File","text":"<p>Update the main adapters <code>__init__.py</code> file to include your new adapter:</p> <pre><code># candles_feed/adapters/__init__.py\n\n# Import all adapters\nfrom candles_feed.adapters.base_adapter import BaseAdapter\nfrom candles_feed.adapters.binance_spot.binance_spot_adapter import BinanceSpotAdapter\nfrom candles_feed.adapters.bybit_spot.bybit_spot_adapter import BybitSpotAdapter\nfrom candles_feed.adapters.coinbase_advanced_trade.coinbase_advanced_trade_adapter import CoinbaseAdvancedTradeAdapter\nfrom candles_feed.adapters.kraken_spot.kraken_spot_adapter import KrakenSpotAdapter\nfrom candles_feed.adapters.kucoin_spot.kucoin_spot_adapter import KuCoinSpotAdapter\nfrom candles_feed.adapters.okx_spot.okx_spot_adapter import OKXSpotAdapter\nfrom candles_feed.adapters.your_exchange_name.your_exchange_adapter import YourExchangeAdapter  # Add your adapter here\n\n# Export all adapters\n__all__ = [\n    \"BaseAdapter\",\n    \"BinanceSpotAdapter\",\n    \"BybitSpotAdapter\",\n    \"CoinbaseAdvancedTradeAdapter\",\n    \"KrakenSpotAdapter\",\n    \"KuCoinSpotAdapter\",\n    \"OKXSpotAdapter\",\n    \"YourExchangeAdapter\"  # Add your adapter here\n]\n</code></pre>"},{"location":"adapters/implementation/#implementation-workflow","title":"Implementation Workflow","text":"<pre><code>flowchart TD\n    A[Study Exchange API Docs] --&gt; B[Identify Endpoints]\n    B --&gt; C[Define Constants]\n    C --&gt; D[Implement Trading Pair Format]\n    D --&gt; E[Implement REST Parameters]\n    E --&gt; F[Implement REST Response Parsing]\n    F --&gt; G[Implement WebSocket Subscription]\n    G --&gt; H[Implement WebSocket Message Parsing]\n    H --&gt; I[Test Your Adapter]\n\n    style I fill:#f96,stroke:#333,stroke-width:2px</code></pre>"},{"location":"adapters/implementation/#key-considerations","title":"Key Considerations","text":"<ol> <li>API Documentation: Thoroughly study the exchange's API documentation to understand:</li> <li>Endpoint structure</li> <li>Required parameters</li> <li>Response formats</li> <li>Rate limits</li> <li> <p>Authentication (if needed)</p> </li> <li> <p>Error Handling: Implement robust error handling for:</p> </li> <li>Network errors</li> <li>Invalid responses</li> <li>Rate limiting</li> <li> <p>API changes</p> </li> <li> <p>Edge Cases: Consider edge cases such as:</p> </li> <li>Different interval formats</li> <li>Timestamp conversions</li> <li>Special trading pair formats</li> <li> <p>Missing data fields</p> </li> <li> <p>Performance: Optimize for performance by:</p> </li> <li>Minimizing unnecessary conversions</li> <li>Handling large datasets efficiently</li> <li> <p>Using appropriate data structures</p> </li> <li> <p>Testing: Test your adapter with real API calls to ensure:</p> </li> <li>Correct data parsing</li> <li>Handling of different trading pairs</li> <li>Proper WebSocket connection management</li> <li>Robustness to API changes</li> </ol>"},{"location":"adapters/implementation/#next-steps","title":"Next Steps","text":"<p>Once you've implemented the basic adapter structure, proceed to:</p> <ol> <li>REST API Integration: Detailed guide for REST API implementation</li> <li>WebSocket Integration: Detailed guide for WebSocket implementation</li> <li>Testing Your Adapter: Guide for thoroughly testing your adapter</li> </ol>"},{"location":"adapters/overview/","title":"Adding New Exchange Adapters","text":"<p>This section provides a guide to adding support for a new exchange to the Candles Feed framework. By implementing an adapter, you can seamlessly integrate a new exchange into the framework.</p>"},{"location":"adapters/overview/#what-is-an-exchange-adapter","title":"What is an Exchange Adapter?","text":"<p>An exchange adapter is a class that implements the <code>BaseAdapter</code> interface and provides exchange-specific logic for:</p> <ol> <li>Formatting trading pairs</li> <li>Constructing REST API requests</li> <li>Parsing REST API responses</li> <li>Creating WebSocket subscription payloads</li> <li>Parsing WebSocket messages</li> <li>Defining supported intervals</li> </ol> <p>The adapter serves as a bridge between the exchange's API and the standardized data format used by the framework.</p>"},{"location":"adapters/overview/#adapter-registration-process","title":"Adapter Registration Process","text":"<pre><code>graph TD\n    A[Create Exchange Adapter Class] --&gt; B[Inherit from BaseAdapter]\n    B --&gt; C[Implement Required Methods]\n    C --&gt; D[Define Constants]\n    D --&gt; E[Register with ExchangeRegistry]\n    E --&gt; F[Adapter Available for Use]\n\n    style E fill:#f96,stroke:#333,stroke-width:2px</code></pre>"},{"location":"adapters/overview/#required-components","title":"Required Components","text":"<p>To add support for a new exchange, you'll need to create:</p> <ol> <li>A constants file with exchange-specific values</li> <li>An adapter class implementing the <code>BaseAdapter</code> interface</li> <li>An <code>__init__.py</code> file to expose your adapter</li> </ol>"},{"location":"adapters/overview/#project-structure","title":"Project Structure","text":"<p>Your adapter should follow this structure:</p> <pre><code>candles_feed/\n\u2514\u2500\u2500 adapters/\n    \u2514\u2500\u2500 your_exchange_name/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 constants.py\n        \u2514\u2500\u2500 your_exchange_adapter.py\n</code></pre>"},{"location":"adapters/overview/#registration","title":"Registration","text":"<p>To make your adapter available to the framework, you need to register it with the <code>ExchangeRegistry</code>:</p> <pre><code>@ExchangeRegistry.register(\"your_exchange_name\")\nclass YourExchangeAdapter(BaseAdapter):\n    \"\"\"Your exchange adapter implementation.\"\"\"\n    # Implementation details here\n</code></pre>"},{"location":"adapters/overview/#adapter-interface","title":"Adapter Interface","text":"<p>Your adapter must implement all methods defined in the <code>BaseAdapter</code> class:</p> <pre><code>classDiagram\n    class BaseAdapter {\n        &lt;&lt;abstract&gt;&gt;\n        +get_trading_pair_format(trading_pair: str) str\n        +get_rest_url() str\n        +get_ws_url() str\n        +get_rest_params(trading_pair, interval, start_time, end_time, limit) dict\n        +parse_rest_response(data: dict) List[CandleData]\n        +get_ws_subscription_payload(trading_pair, interval) dict\n        +parse_ws_message(data: dict) Optional[List[CandleData]]\n        +get_supported_intervals() Dict[str, int]\n        +get_ws_supported_intervals() List[str]\n    }\n\n    class YourExchangeAdapter {\n        +get_trading_pair_format(trading_pair: str) str\n        +get_rest_url() str\n        +get_ws_url() str\n        +get_rest_params(trading_pair, interval, start_time, end_time, limit) dict\n        +parse_rest_response(data: dict) List[CandleData]\n        +get_ws_subscription_payload(trading_pair, interval) dict\n        +parse_ws_message(data: dict) Optional[List[CandleData]]\n        +get_supported_intervals() Dict[str, int]\n        +get_ws_supported_intervals() List[str]\n    }\n\n    BaseAdapter &lt;|-- YourExchangeAdapter</code></pre>"},{"location":"adapters/overview/#next-steps","title":"Next Steps","text":"<p>In the following sections, we'll walk through the process of implementing each part of an exchange adapter:</p> <ol> <li>Adapter Implementation: Creating the basic adapter structure</li> <li>REST API Integration: Implementing REST API functionality</li> <li>WebSocket Integration: Implementing WebSocket functionality</li> <li>Testing Your Adapter: Ensuring your adapter works correctly</li> </ol>"},{"location":"adapters/rest_api/","title":"REST API Integration","text":"<p>This guide focuses on implementing the REST API aspects of your exchange adapter. Proper REST API integration is crucial for fetching historical candle data and providing a fallback when WebSocket connectivity is unavailable.</p>"},{"location":"adapters/rest_api/#understanding-exchange-rest-api","title":"Understanding Exchange REST API","text":"<p>Before implementing, thoroughly understand how the exchange's REST API works:</p> <pre><code>graph TD\n    A[Study API Documentation] --&gt; B{Requires Authentication?}\n    B --&gt;|Yes| C[Implement Auth Mechanism]\n    B --&gt;|No| D[Identify Candles Endpoint]\n    C --&gt; D\n    D --&gt; E[Understand Parameter Format]\n    E --&gt; F[Determine Response Format]\n    F --&gt; G[Check Rate Limits]\n    G --&gt; H[Implement REST Methods]</code></pre>"},{"location":"adapters/rest_api/#rest-methods-implementation","title":"REST Methods Implementation","text":"<p>Your adapter needs to implement these REST-related methods:</p> <ol> <li><code>get_rest_url()</code>: Returns the REST API URL</li> <li><code>get_rest_params()</code>: Creates parameters for the REST request</li> <li><code>parse_rest_response()</code>: Parses the REST API response into CandleData objects</li> </ol> <p>Let's look at each in detail:</p>"},{"location":"adapters/rest_api/#1-implementing-get_rest_url","title":"1. Implementing <code>get_rest_url()</code>","text":"<pre><code>def get_rest_url(self) -&gt; str:\n    \"\"\"Get REST API URL for candles.\n\n    Returns:\n        REST API URL\n    \"\"\"\n    # For most exchanges, this is a simple concatenation\n    return f\"{REST_URL}{CANDLES_ENDPOINT}\"\n\n    # Some exchanges might require path parameters in the URL\n    # Example: return f\"{REST_URL}{CANDLES_ENDPOINT}\".format(product_id=some_id)\n</code></pre>"},{"location":"adapters/rest_api/#2-implementing-get_rest_params","title":"2. Implementing <code>get_rest_params()</code>","text":"<p>This method creates the parameter dictionary for REST API requests:</p> <pre><code>def get_rest_params(self, \n                  trading_pair: str, \n                  interval: str, \n                  start_time: Optional[int] = None, \n                  end_time: Optional[int] = None, \n                  limit: Optional[int] = None) -&gt; dict:\n    \"\"\"Get parameters for REST API request.\"\"\"\n    # Basic parameters needed for most exchanges\n    params = {\n        \"symbol\": self.get_trading_pair_format(trading_pair),\n        \"interval\": self._convert_interval_to_exchange_format(interval),\n        \"limit\": limit or MAX_RESULTS_PER_CANDLESTICK_REST_REQUEST\n    }\n\n    # Handle timestamps according to exchange requirements\n    if start_time is not None:\n        # Some exchanges require milliseconds\n        params[\"startTime\"] = start_time * 1000  # Convert to milliseconds\n        # Or some might use a different parameter name\n        # params[\"from\"] = start_time\n\n    if end_time is not None:\n        # Some exchanges require milliseconds\n        params[\"endTime\"] = end_time * 1000  # Convert to milliseconds\n        # Or some might use a different parameter name\n        # params[\"to\"] = end_time\n\n    return params\n</code></pre>"},{"location":"adapters/rest_api/#3-implementing-parse_rest_response","title":"3. Implementing <code>parse_rest_response()</code>","text":"<p>This method parses the exchange's response into standardized <code>CandleData</code> objects:</p> <pre><code>def parse_rest_response(self, data: dict) -&gt; List[CandleData]:\n    \"\"\"Parse REST API response into CandleData objects.\"\"\"\n    candles = []\n\n    # Extract data based on exchange's response format\n    # This will vary significantly between exchanges\n    response_data = data.get(\"candles\", [])  # Adjust key based on exchange's format\n\n    for item in response_data:\n        # For array-based responses\n        if isinstance(item, list):\n            # Adjust indices based on exchange's format\n            candles.append(CandleData(\n                timestamp_raw=item[0],        # Timestamp\n                open=float(item[1]),          # Open price\n                high=float(item[2]),          # High price\n                low=float(item[3]),           # Low price\n                close=float(item[4]),         # Close price\n                volume=float(item[5]),        # Volume\n                quote_asset_volume=float(item[6]) if len(item) &gt; 6 else 0.0,\n                n_trades=int(item[7]) if len(item) &gt; 7 else 0,\n                taker_buy_base_volume=float(item[8]) if len(item) &gt; 8 else 0.0,\n                taker_buy_quote_volume=float(item[9]) if len(item) &gt; 9 else 0.0\n            ))\n\n        # For object-based responses\n        elif isinstance(item, dict):\n            # Adjust keys based on exchange's format\n            candles.append(CandleData(\n                timestamp_raw=item.get(\"time\", 0),       # Timestamp\n                open=float(item.get(\"open\", 0)),         # Open price\n                high=float(item.get(\"high\", 0)),         # High price\n                low=float(item.get(\"low\", 0)),           # Low price\n                close=float(item.get(\"close\", 0)),       # Close price\n                volume=float(item.get(\"volume\", 0)),     # Volume\n                quote_asset_volume=float(item.get(\"quoteVolume\", 0)),\n                n_trades=int(item.get(\"trades\", 0)),\n                taker_buy_base_volume=float(item.get(\"takerBuyVolume\", 0)),\n                taker_buy_quote_volume=float(item.get(\"takerBuyQuoteVolume\", 0))\n            ))\n\n    return candles\n</code></pre>"},{"location":"adapters/rest_api/#common-rest-api-patterns","title":"Common REST API Patterns","text":"<p>Different exchanges structure their REST APIs differently. Here are common patterns:</p>"},{"location":"adapters/rest_api/#timestamp-formats","title":"Timestamp Formats","text":"<p>Exchanges use various timestamp formats:</p> <pre><code>graph TD\n    A[Timestamp Formats] --&gt; B[Seconds]\n    A --&gt; C[Milliseconds]\n    A --&gt; D[ISO 8601]\n\n    B --&gt; B1[\"start: 1625097600\"]\n    C --&gt; C1[\"startTime: 1625097600000\"]\n    D --&gt; D1[\"start_time: '2021-07-01T00:00:00Z'\"]</code></pre> <p>Always validate the timestamps and convert them to the framework's standard format (seconds).</p>"},{"location":"adapters/rest_api/#interval-formats","title":"Interval Formats","text":"<p>Exchanges use different formats for intervals:</p> Exchange 1 minute 1 hour 1 day Binance \"1m\" \"1h\" \"1d\" Bybit \"1\" \"60\" \"D\" KuCoin \"1min\" \"1hour\" \"1day\" OKX \"1m\" \"1H\" \"1D\" <p>Create a mapping in your constants file:</p> <pre><code>INTERVAL_TO_EXCHANGE_FORMAT = {\n    \"1m\": \"1min\",   # Standard -&gt; Exchange format\n    \"5m\": \"5min\",\n    \"1h\": \"60min\",\n    \"1d\": \"1day\"\n}\n</code></pre> <p>Then use it in your <code>get_rest_params()</code> method:</p> <pre><code>params[\"interval\"] = INTERVAL_TO_EXCHANGE_FORMAT.get(interval, interval)\n</code></pre>"},{"location":"adapters/rest_api/#response-formats","title":"Response Formats","text":"<p>Exchanges structure their responses differently:</p>"},{"location":"adapters/rest_api/#array-based-response","title":"Array-Based Response","text":"<pre><code>{\n  \"data\": [\n    [1625097600, \"34500.5\", \"34650.0\", \"34400.2\", \"34600.1\", \"120.5\"],\n    [1625097660, \"34600.1\", \"34700.0\", \"34550.0\", \"34650.8\", \"95.2\"]\n  ]\n}\n</code></pre>"},{"location":"adapters/rest_api/#object-based-response","title":"Object-Based Response","text":"<pre><code>{\n  \"candles\": [\n    {\n      \"time\": 1625097600,\n      \"open\": \"34500.5\",\n      \"high\": \"34650.0\",\n      \"low\": \"34400.2\",\n      \"close\": \"34600.1\",\n      \"volume\": \"120.5\"\n    },\n    {\n      \"time\": 1625097660,\n      \"open\": \"34600.1\",\n      \"high\": \"34700.0\",\n      \"low\": \"34550.0\",\n      \"close\": \"34650.8\",\n      \"volume\": \"95.2\"\n    }\n  ]\n}\n</code></pre>"},{"location":"adapters/rest_api/#error-handling","title":"Error Handling","text":"<p>Implement robust error handling in your REST API methods:</p> <pre><code>def parse_rest_response(self, data: dict) -&gt; List[CandleData]:\n    \"\"\"Parse REST API response into CandleData objects.\"\"\"\n    candles = []\n\n    # Check for error response\n    if \"error\" in data and data[\"error\"]:\n        error_msg = data.get(\"message\", \"Unknown error\")\n        raise ValueError(f\"Exchange error: {error_msg}\")\n\n    # Check if data is in expected format\n    if \"candles\" not in data:\n        raise ValueError(f\"Unexpected response format: {data}\")\n\n    # Parse candles with validation\n    for item in data[\"candles\"]:\n        try:\n            candles.append(CandleData(\n                timestamp_raw=item.get(\"time\", 0),\n                open=float(item.get(\"open\", 0)),\n                high=float(item.get(\"high\", 0)),\n                low=float(item.get(\"low\", 0)),\n                close=float(item.get(\"close\", 0)),\n                volume=float(item.get(\"volume\", 0))\n            ))\n        except (ValueError, TypeError) as e:\n            # Log error but continue processing\n            logger.warning(f\"Error parsing candle data: {e}, data: {item}\")\n\n    return candles\n</code></pre>"},{"location":"adapters/rest_api/#rate-limiting","title":"Rate Limiting","text":"<p>Respect the exchange's rate limits to avoid being banned:</p> <pre><code># In your constants.py file\nRATE_LIMITS = [\n    RateLimit(limit_id=\"CANDLES\", limit=60, time_interval=60)  # 60 requests per minute\n]\n\n# In your adapter implementation\ndef get_rate_limits(self) -&gt; List[RateLimit]:\n    \"\"\"Get rate limits for the exchange.\"\"\"\n    return RATE_LIMITS\n</code></pre>"},{"location":"adapters/rest_api/#testing-rest-api-integration","title":"Testing REST API Integration","text":"<p>Test your REST implementation with various scenarios:</p> <ol> <li>Fetching recent candles</li> <li>Fetching historical candles</li> <li>Handling pagination</li> <li>Error conditions</li> <li>Rate limit behavior</li> </ol> <p>Example test:</p> <pre><code>def test_parse_rest_response():\n    \"\"\"Test parsing REST response.\"\"\"\n    adapter = YourExchangeAdapter()\n\n    # Sample response data\n    response = {\n        \"candles\": [\n            {\n                \"time\": 1625097600,\n                \"open\": \"34500.5\",\n                \"high\": \"34650.0\",\n                \"low\": \"34400.2\",\n                \"close\": \"34600.1\",\n                \"volume\": \"120.5\"\n            }\n        ]\n    }\n\n    candles = adapter.parse_rest_response(response)\n\n    assert len(candles) == 1\n    assert candles[0].timestamp == 1625097600\n    assert candles[0].open == 34500.5\n    assert candles[0].high == 34650.0\n    assert candles[0].low == 34400.2\n    assert candles[0].close == 34600.1\n    assert candles[0].volume == 120.5\n</code></pre>"},{"location":"adapters/rest_api/#next-steps","title":"Next Steps","text":"<p>After implementing REST API functionality, proceed to:</p> <ol> <li>WebSocket Integration: Implementing real-time data collection</li> <li>Testing Your Adapter: Comprehensive testing strategy</li> </ol>"},{"location":"adapters/testing/","title":"Testing Your Adapter","text":"<p>A thoroughly tested adapter ensures reliability and robustness. This guide covers strategies for testing your exchange adapter implementation.</p>"},{"location":"adapters/testing/#testing-strategy-overview","title":"Testing Strategy Overview","text":"<p>A comprehensive testing strategy includes:</p> <pre><code>graph TD\n    A[Testing Strategy] --&gt; B[Unit Tests]\n    A --&gt; C[Integration Tests]\n    A --&gt; D[End-to-End Tests]\n    A --&gt; E[Mock Tests]\n\n    B --&gt; B1[Test individual methods]\n    B --&gt; B2[Test with various inputs]\n    B --&gt; B3[Test edge cases]\n\n    C --&gt; C1[Test with real API]\n    C --&gt; C2[Test network behavior]\n\n    D --&gt; D1[Test complete data flow]\n    D --&gt; D2[Test with real exchange]\n\n    E --&gt; E1[Test with mock responses]\n    E --&gt; E2[Test error handling]\n\n    style B fill:#d0f0c0\n    style C fill:#f0d0c0\n    style D fill:#c0d0f0\n    style E fill:#f0c0d0</code></pre>"},{"location":"adapters/testing/#unit-tests","title":"Unit Tests","text":"<p>Unit tests verify individual components of your adapter work correctly in isolation:</p>"},{"location":"adapters/testing/#1-testing-get_trading_pair_format","title":"1. Testing <code>get_trading_pair_format()</code>","text":"<pre><code>def test_get_trading_pair_format():\n    \"\"\"Test trading pair format conversion.\"\"\"\n    adapter = YourExchangeAdapter()\n\n    # Test with various trading pairs\n    assert adapter.get_trading_pair_format(\"BTC-USDT\") == \"BTCUSDT\"\n    assert adapter.get_trading_pair_format(\"ETH-BTC\") == \"ETHBTC\"\n    assert adapter.get_trading_pair_format(\"SOL-USDC\") == \"SOLUSDC\"\n\n    # Test with special cases if your exchange has them\n    assert adapter.get_trading_pair_format(\"BTC-USD\") == \"BTC-USD\"  # Kraken example\n</code></pre>"},{"location":"adapters/testing/#2-testing-get_rest_params","title":"2. Testing <code>get_rest_params()</code>","text":"<pre><code>def test_get_rest_params():\n    \"\"\"Test REST API parameters generation.\"\"\"\n    adapter = YourExchangeAdapter()\n\n    # Test with minimal parameters\n    params = adapter.get_rest_params(\"BTC-USDT\", \"1m\")\n    assert params[\"symbol\"] == \"BTCUSDT\"\n    assert params[\"interval\"] == \"1m\"\n    assert \"limit\" in params\n\n    # Test with all parameters\n    params = adapter.get_rest_params(\n        \"ETH-USDT\", \n        \"1h\", \n        start_time=1625097600,\n        end_time=1625184000,\n        limit=500\n    )\n    assert params[\"symbol\"] == \"ETHUSDT\"\n    assert params[\"interval\"] == \"1h\"\n    assert params[\"limit\"] == 500\n    # Check timestamp formats (adjust based on your exchange)\n    assert params[\"startTime\"] == 1625097600000  # If exchange uses milliseconds\n    assert params[\"endTime\"] == 1625184000000\n</code></pre>"},{"location":"adapters/testing/#3-testing-parse_rest_response","title":"3. Testing <code>parse_rest_response()</code>","text":"<pre><code>def test_parse_rest_response():\n    \"\"\"Test parsing REST API responses.\"\"\"\n    adapter = YourExchangeAdapter()\n\n    # Sample response based on your exchange's format\n    response = {\n        \"candles\": [\n            # Format depends on exchange\n            {\n                \"timestamp\": 1625097600000,\n                \"open\": \"35000.0\",\n                \"high\": \"35100.0\",\n                \"low\": \"34900.0\",\n                \"close\": \"35050.0\",\n                \"volume\": \"10.5\"\n            }\n        ]\n    }\n\n    candles = adapter.parse_rest_response(response)\n\n    # Verify results\n    assert len(candles) == 1\n    assert candles[0].timestamp == 1625097600  # Should be in seconds\n    assert candles[0].open == 35000.0\n    assert candles[0].high == 35100.0\n    assert candles[0].low == 34900.0\n    assert candles[0].close == 35050.0\n    assert candles[0].volume == 10.5\n</code></pre>"},{"location":"adapters/testing/#4-testing-parse_ws_message","title":"4. Testing <code>parse_ws_message()</code>","text":"<pre><code>def test_parse_ws_message():\n    \"\"\"Test parsing WebSocket messages.\"\"\"\n    adapter = YourExchangeAdapter()\n\n    # Test with candle update message\n    message = {\n        # Format depends on exchange\n        \"e\": \"kline\",\n        \"k\": {\n            \"t\": 1625097600000,\n            \"o\": \"35000.0\",\n            \"h\": \"35100.0\",\n            \"l\": \"34900.0\",\n            \"c\": \"35050.0\",\n            \"v\": \"10.5\"\n        }\n    }\n\n    candles = adapter.parse_ws_message(message)\n\n    # Verify results\n    assert candles is not None\n    assert len(candles) == 1\n    assert candles[0].timestamp == 1625097600  # Should be in seconds\n    assert candles[0].open == 35000.0\n\n    # Test with non-candle message\n    other_message = {\"type\": \"ping\"}\n    assert adapter.parse_ws_message(other_message) is None\n</code></pre>"},{"location":"adapters/testing/#5-testing-interval-support","title":"5. Testing Interval Support","text":"<pre><code>def test_supported_intervals():\n    \"\"\"Test interval support methods.\"\"\"\n    adapter = YourExchangeAdapter()\n\n    # Test supported intervals\n    intervals = adapter.get_supported_intervals()\n    assert \"1m\" in intervals\n    assert \"1h\" in intervals\n    assert intervals[\"1m\"] == 60\n    assert intervals[\"1h\"] == 3600\n\n    # Test WebSocket-supported intervals\n    ws_intervals = adapter.get_ws_supported_intervals()\n    assert isinstance(ws_intervals, list)\n    # Check specific intervals\n    assert \"1m\" in ws_intervals\n</code></pre>"},{"location":"adapters/testing/#integration-tests-with-mocks","title":"Integration Tests with Mocks","text":"<p>Test your adapter with mocked network responses:</p> <pre><code>@pytest.mark.asyncio\nasync def test_fetch_candles_with_mock():\n    \"\"\"Test fetching candles with mock responses.\"\"\"\n    # Create adapter\n    adapter = YourExchangeAdapter()\n\n    # Create mock for network client\n    mock_client = MagicMock()\n    mock_client.get_rest_data = AsyncMock()\n\n    # Set up mock response\n    mock_response = {\n        \"candles\": [\n            # Exchange-specific format\n        ]\n    }\n    mock_client.get_rest_data.return_value = mock_response\n\n    # Create strategy with mocks\n    strategy = RESTPollingStrategy(\n        network_client=mock_client,\n        adapter=adapter,\n        trading_pair=\"BTC-USDT\",\n        interval=\"1m\",\n        data_processor=DataProcessor(),\n        candles_store=deque(maxlen=100)\n    )\n\n    # Test fetch_candles\n    candles = await strategy.fetch_candles(\n        start_time=1625097600,\n        end_time=1625184000\n    )\n\n    # Verify mock was called with correct params\n    expected_params = adapter.get_rest_params(\n        \"BTC-USDT\", \"1m\", \n        start_time=1625097600,\n        end_time=1625184000\n    )\n    mock_client.get_rest_data.assert_called_once()\n    args, kwargs = mock_client.get_rest_data.call_args\n    assert kwargs[\"params\"] == expected_params\n\n    # Verify results\n    assert len(candles) &gt; 0\n</code></pre>"},{"location":"adapters/testing/#integration-tests-with-real-api","title":"Integration Tests with Real API","text":"<p>Test your adapter with the actual exchange API:</p> <pre><code>@pytest.mark.integration\n@pytest.mark.asyncio\nasync def test_real_api_fetch():\n    \"\"\"Test fetching from real API.\n\n    Note: These tests require internet connection and may be rate-limited.\n    \"\"\"\n    # Create real adapter and components\n    adapter = YourExchangeAdapter()\n    throttler = AsyncThrottler(rate_limits=[])\n    network_client = NetworkClient(throttler)\n    data_processor = DataProcessor()\n\n    # Create strategy\n    strategy = RESTPollingStrategy(\n        network_client=network_client,\n        adapter=adapter,\n        trading_pair=\"BTC-USDT\",\n        interval=\"1m\",\n        data_processor=data_processor,\n        candles_store=deque(maxlen=100)\n    )\n\n    # Fetch recent candles\n    end_time = int(time.time())\n    start_time = end_time - 3600  # Last hour\n\n    candles = await strategy.fetch_candles(\n        start_time=start_time,\n        end_time=end_time\n    )\n\n    # Verify results\n    assert len(candles) &gt; 0\n    assert all(isinstance(c, CandleData) for c in candles)\n    assert all(start_time &lt;= c.timestamp &lt;= end_time for c in candles)\n\n    # Verify candles are properly formatted\n    for candle in candles:\n        assert candle.high &gt;= candle.low\n        assert candle.high &gt;= candle.open\n        assert candle.high &gt;= candle.close\n        assert candle.low &lt;= candle.open\n        assert candle.low &lt;= candle.close\n        assert candle.volume &gt;= 0\n</code></pre>"},{"location":"adapters/testing/#websocket-tests","title":"WebSocket Tests","text":"<p>Test WebSocket functionality:</p> <pre><code>@pytest.mark.asyncio\nasync def test_websocket_subscription():\n    \"\"\"Test WebSocket subscription with mock.\"\"\"\n    # Create adapter\n    adapter = YourExchangeAdapter()\n\n    # Create mock WebSocket assistant\n    mock_ws = AsyncMock()\n    mock_ws.connect = AsyncMock()\n    mock_ws.send = AsyncMock()\n    mock_ws.disconnect = AsyncMock()\n\n    # Create mock for iter_messages\n    message_queue = asyncio.Queue()\n\n    # Add sample messages to queue\n    await message_queue.put(MagicMock(data={\"type\": \"subscription_success\"}))\n    await message_queue.put(MagicMock(data={\"e\": \"kline\", \"k\": {...}}))\n\n    # Mock the iter_messages method\n    async def mock_iter_messages():\n        while not message_queue.empty():\n            yield await message_queue.get()\n\n    mock_ws.iter_messages = mock_iter_messages\n\n    # Create mock network client\n    mock_client = MagicMock()\n    mock_client.establish_ws_connection = AsyncMock(return_value=mock_ws)\n    mock_client.send_ws_message = AsyncMock()\n\n    # Create strategy\n    strategy = WebSocketStrategy(\n        network_client=mock_client,\n        adapter=adapter,\n        trading_pair=\"BTC-USDT\",\n        interval=\"1m\",\n        data_processor=DataProcessor(),\n        candles_store=deque(maxlen=100)\n    )\n\n    # Start strategy (will connect and subscribe)\n    await strategy.start()\n\n    # Wait for messages to be processed\n    await asyncio.sleep(0.1)\n\n    # Verify connection and subscription\n    mock_client.establish_ws_connection.assert_called_once_with(adapter.get_ws_url())\n    mock_client.send_ws_message.assert_called_once()\n\n    # Clean up\n    await strategy.stop()\n    mock_ws.disconnect.assert_called_once()\n</code></pre>"},{"location":"adapters/testing/#end-to-end-tests","title":"End-to-End Tests","text":"<p>Test the complete flow using the <code>CandlesFeed</code> class:</p> <pre><code>@pytest.mark.integration\n@pytest.mark.asyncio\nasync def test_candles_feed_e2e():\n    \"\"\"Test complete candles feed flow.\"\"\"\n    # Create adapter\n    adapter = YourExchangeAdapter()\n\n    # Create candles feed\n    feed = CandlesFeed(\n        adapter=adapter,\n        trading_pair=\"BTC-USDT\",\n        interval=\"1m\",\n        max_records=100\n    )\n\n    # Start feed\n    await feed.start()\n\n    # Wait for some data\n    start_time = time.time()\n    while not feed.ready and time.time() - start_time &lt; 30:\n        await asyncio.sleep(1)\n\n    # Get data as dataframe\n    df = feed.get_candles_df()\n\n    # Verify we have data\n    assert not df.empty\n    assert all(col in df.columns for col in [\n        \"timestamp\", \"open\", \"high\", \"low\", \"close\", \"volume\"\n    ])\n\n    # Clean up\n    await feed.stop()\n</code></pre>"},{"location":"adapters/testing/#test-for-edge-cases","title":"Test For Edge Cases","text":"<p>Be sure to test various edge cases:</p> <ol> <li>Invalid Inputs: Test with invalid trading pairs, intervals, timestamps</li> <li>Error Responses: Test handling of API errors and rate limiting</li> <li>Empty Results: Test with empty response data</li> <li>Missing Fields: Test with responses missing some fields</li> <li>Connection Issues: Test recovery from network interruptions</li> <li>Partial Updates: Test handling of partial candle updates</li> </ol> <pre><code>def test_parse_rest_response_empty():\n    \"\"\"Test parsing empty REST response.\"\"\"\n    adapter = YourExchangeAdapter()\n\n    # Empty response\n    response = {\"candles\": []}\n    candles = adapter.parse_rest_response(response)\n    assert len(candles) == 0\n\n    # Missing 'candles' key\n    response = {\"other\": []}\n    candles = adapter.parse_rest_response(response)\n    assert len(candles) == 0\n\ndef test_parse_rest_response_missing_fields():\n    \"\"\"Test parsing REST response with missing fields.\"\"\"\n    adapter = YourExchangeAdapter()\n\n    # Response with missing fields\n    response = {\n        \"candles\": [\n            {\n                \"timestamp\": 1625097600000,\n                \"open\": \"35000.0\",\n                # Missing high, low\n                \"close\": \"35050.0\",\n                \"volume\": \"10.5\"\n            }\n        ]\n    }\n\n    # Adapter should handle missing fields gracefully\n    candles = adapter.parse_rest_response(response)\n    assert len(candles) == 1\n    assert candles[0].high == 0.0  # Default value\n    assert candles[0].low == 0.0   # Default value\n</code></pre>"},{"location":"adapters/testing/#continuous-integration","title":"Continuous Integration","text":"<p>Set up CI to run tests automatically:</p> <pre><code># .github/workflows/test.yml\nname: Tests\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: 3.9\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install pytest pytest-asyncio aioresponses\n        pip install -e .\n\n    - name: Test with pytest\n      run: |\n        pytest tests/unit\n\n    - name: Integration tests\n      if: github.event_name == 'push'\n      run: |\n        pytest tests/integration -m \"not slow\"\n</code></pre>"},{"location":"adapters/testing/#test-documentation","title":"Test Documentation","text":"<p>Document your test approach in your code:</p> <pre><code>\"\"\"Tests for YourExchangeAdapter.\n\nThis module provides tests for the YourExchange adapter implementation.\n\nTest categories:\n1. Unit tests: Test individual methods\n2. Integration tests: Test with (mocked) API\n3. End-to-end tests: Test complete flow\n\nRun tests with:\n  pytest -xvs tests/adapters/your_exchange_name/\n\nRun only unit tests:\n  pytest -xvs tests/adapters/your_exchange_name/ -k \"not integration\"\n\nRun only integration tests:\n  pytest -xvs tests/adapters/your_exchange_name/ -k \"integration\"\n\"\"\"\n</code></pre>"},{"location":"adapters/testing/#test-directory-structure","title":"Test Directory Structure","text":"<p>Organize your tests in a structure mirroring your implementation:</p> <pre><code>tests/\n\u2514\u2500\u2500 adapters/\n    \u2514\u2500\u2500 your_exchange_name/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 test_your_exchange_adapter.py\n        \u251c\u2500\u2500 test_rest_integration.py\n        \u2514\u2500\u2500 test_ws_integration.py\n</code></pre>"},{"location":"adapters/testing/#final-checklist","title":"Final Checklist","text":"<p>Before submitting your adapter, ensure:</p> <ul> <li> All unit tests pass</li> <li> Integration tests with mock API pass</li> <li> Integration tests with real API pass (if possible)</li> <li> WebSocket tests pass</li> <li> Edge cases are handled gracefully</li> <li> Code follows project style guide</li> <li> Documentation is complete</li> <li> Example usage is provided</li> </ul> <p>With thorough testing, your adapter will be reliable and maintainable, providing a solid foundation for traders using the framework with your exchange.</p>"},{"location":"adapters/testing/#next-steps","title":"Next Steps","text":"<p>After completing and testing your adapter, consider:</p> <ol> <li>Submitting a pull request to contribute it to the main repository</li> <li>Adding advanced features like authentication for private endpoints</li> <li>Creating examples demonstrating your adapter's usage</li> <li>Writing documentation for exchange-specific quirks or features</li> </ol>"},{"location":"adapters/websocket/","title":"WebSocket Integration","text":"<p>WebSocket integration is crucial for receiving real-time candle updates from exchanges. This guide covers how to implement WebSocket functionality in your exchange adapter.</p>"},{"location":"adapters/websocket/#websocket-vs-rest","title":"WebSocket vs REST","text":"<p>Before diving into implementation, understand the benefits of WebSocket:</p> <pre><code>graph TD\n    A[Data Collection Methods] --&gt; B[WebSocket]\n    A --&gt; C[REST Polling]\n\n    B --&gt; B1[Real-time updates]\n    B --&gt; B2[Lower latency]\n    B --&gt; B3[Reduced API calls]\n    B --&gt; B4[Less bandwidth]\n\n    C --&gt; C1[Simpler implementation]\n    C --&gt; C2[More reliable]\n    C --&gt; C3[Works for all intervals]\n    C --&gt; C4[Better for historical data]\n\n    style B fill:#d4f4dd\n    style C fill:#f4d4d4</code></pre>"},{"location":"adapters/websocket/#websocket-methods-implementation","title":"WebSocket Methods Implementation","text":"<p>Your adapter needs to implement these WebSocket-related methods:</p> <ol> <li><code>get_ws_url()</code>: Returns the WebSocket URL</li> <li><code>get_ws_subscription_payload()</code>: Creates the subscription payload</li> <li><code>parse_ws_message()</code>: Parses WebSocket messages into CandleData objects</li> <li><code>get_ws_supported_intervals()</code>: Returns intervals supported via WebSocket</li> </ol> <p>Let's explore each method in detail:</p>"},{"location":"adapters/websocket/#1-implementing-get_ws_url","title":"1. Implementing <code>get_ws_url()</code>","text":"<pre><code>def get_ws_url(self) -&gt; str:\n    \"\"\"Get WebSocket URL.\n\n    Returns:\n        WebSocket URL\n    \"\"\"\n    return WSS_URL  # Defined in constants.py\n\n    # Some exchanges might have environment-specific URLs\n    # Example: return f\"wss://{self.domain}/ws\"\n</code></pre>"},{"location":"adapters/websocket/#2-implementing-get_ws_subscription_payload","title":"2. Implementing <code>get_ws_subscription_payload()</code>","text":"<p>This method creates the payload for subscribing to candle updates:</p> <pre><code>def get_ws_subscription_payload(self, trading_pair: str, interval: str) -&gt; dict:\n    \"\"\"Get WebSocket subscription payload.\n\n    Args:\n        trading_pair: Trading pair\n        interval: Candle interval\n\n    Returns:\n        WebSocket subscription payload\n    \"\"\"\n    # Format varies significantly between exchanges\n    formatted_pair = self.get_trading_pair_format(trading_pair)\n\n    # Example for a simple JSON-based subscription\n    return {\n        \"method\": \"subscribe\",\n        \"params\": [\n            f\"candle.{interval}.{formatted_pair}\"\n        ],\n        \"id\": 1  # Some exchanges require an ID\n    }\n\n    # Alternative example for an exchange with different format\n    # return {\n    #     \"op\": \"subscribe\",\n    #     \"args\": [{\n    #         \"channel\": \"candlestick\",\n    #         \"instId\": formatted_pair,\n    #         \"interval\": interval\n    #     }]\n    # }\n</code></pre>"},{"location":"adapters/websocket/#3-implementing-parse_ws_message","title":"3. Implementing <code>parse_ws_message()</code>","text":"<p>This method parses WebSocket messages into CandleData objects:</p> <pre><code>def parse_ws_message(self, data: dict) -&gt; Optional[List[CandleData]]:\n    \"\"\"Parse WebSocket message into CandleData objects.\n\n    Args:\n        data: WebSocket message\n\n    Returns:\n        List of CandleData objects or None if message is not a candle update\n    \"\"\"\n    # Check if this is a candle update message\n    if not self._is_candle_message(data):\n        return None\n\n    candles = []\n\n    # Extract candle data from the message\n    # This will vary significantly between exchanges\n\n    # Example for an exchange with a simple format\n    if \"data\" in data and isinstance(data[\"data\"], dict):\n        candle = data[\"data\"]\n        candles.append(CandleData(\n            timestamp_raw=candle.get(\"t\", 0),       # Timestamp\n            open=float(candle.get(\"o\", 0)),         # Open price\n            high=float(candle.get(\"h\", 0)),         # High price\n            low=float(candle.get(\"l\", 0)),          # Low price\n            close=float(candle.get(\"c\", 0)),        # Close price\n            volume=float(candle.get(\"v\", 0)),       # Volume\n            quote_asset_volume=float(candle.get(\"q\", 0)),\n            n_trades=int(candle.get(\"n\", 0)),\n            taker_buy_base_volume=float(candle.get(\"V\", 0)),\n            taker_buy_quote_volume=float(candle.get(\"Q\", 0))\n        ))\n\n    return candles if candles else None\n\ndef _is_candle_message(self, data: dict) -&gt; bool:\n    \"\"\"Check if the WebSocket message is a candle update.\n\n    Args:\n        data: WebSocket message\n\n    Returns:\n        True if the message is a candle update, False otherwise\n    \"\"\"\n    # Implement logic to check if this is a candle message\n    # Example:\n    return (\n        isinstance(data, dict) and\n        data.get(\"e\") == \"kline\" and\n        \"k\" in data\n    )\n</code></pre>"},{"location":"adapters/websocket/#4-implementing-get_ws_supported_intervals","title":"4. Implementing <code>get_ws_supported_intervals()</code>","text":"<p>Not all exchanges support all intervals via WebSocket. This method returns the supported intervals:</p> <pre><code>def get_ws_supported_intervals(self) -&gt; List[str]:\n    \"\"\"Get intervals supported by WebSocket API.\n\n    Returns:\n        List of interval strings supported by WebSocket API\n    \"\"\"\n    return WS_INTERVALS  # Defined in constants.py\n</code></pre>"},{"location":"adapters/websocket/#common-websocket-patterns","title":"Common WebSocket Patterns","text":"<p>Different exchanges structure their WebSocket APIs differently. Here are common patterns:</p>"},{"location":"adapters/websocket/#connection-establishment","title":"Connection Establishment","text":"<p>Some exchanges require special steps to establish a WebSocket connection:</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Exchange\n\n    Client-&gt;&gt;Exchange: Connect to WebSocket URL\n\n    alt Simple Connection\n        Exchange--&gt;&gt;Client: Connection established\n    else Authentication Required\n        Exchange--&gt;&gt;Client: Connection established\n        Client-&gt;&gt;Exchange: Send authentication message\n        Exchange--&gt;&gt;Client: Authentication successful\n    else Token Required\n        Client-&gt;&gt;Exchange: REST request for WebSocket token\n        Exchange--&gt;&gt;Client: Return token\n        Client-&gt;&gt;Exchange: Connect with token\n        Exchange--&gt;&gt;Client: Connection established\n    end\n\n    Client-&gt;&gt;Exchange: Send subscription payload\n    Exchange--&gt;&gt;Client: Subscription confirmed\n    Exchange--&gt;&gt;Client: Begin sending candle updates</code></pre> <p>Implement the appropriate connection logic:</p> <pre><code># For exchanges requiring token (e.g., KuCoin)\nasync def _get_ws_token(self) -&gt; str:\n    \"\"\"Get WebSocket token from REST API.\"\"\"\n    # Implement token retrieval logic\n    rest_assistant = await self._api_factory.get_rest_assistant()\n    response = await rest_assistant.execute_request(\n        url=f\"{REST_URL}{TOKEN_ENDPOINT}\",\n        method=RESTMethod.POST\n    )\n    return response[\"token\"]\n\n# Then use the token in get_ws_url\ndef get_ws_url(self) -&gt; str:\n    \"\"\"Get WebSocket URL with token.\"\"\"\n    token = self._get_ws_token()\n    return f\"{WSS_URL}?token={token}\"\n</code></pre>"},{"location":"adapters/websocket/#subscription-confirmation","title":"Subscription Confirmation","text":"<p>Most exchanges send a confirmation message after subscribing:</p> <pre><code>def parse_ws_message(self, data: dict) -&gt; Optional[List[CandleData]]:\n    \"\"\"Parse WebSocket message.\"\"\"\n    # Check if this is a subscription confirmation\n    if self._is_subscription_confirmation(data):\n        # Log successful subscription\n        logger.info(f\"Successfully subscribed to candle updates: {data}\")\n        return None\n\n    # Continue with normal parsing...\n\ndef _is_subscription_confirmation(self, data: dict) -&gt; bool:\n    \"\"\"Check if the message is a subscription confirmation.\"\"\"\n    # Example implementation\n    return (\n        isinstance(data, dict) and\n        data.get(\"type\") == \"subscribed\" and\n        \"candle\" in data.get(\"channel\", \"\")\n    )\n</code></pre>"},{"location":"adapters/websocket/#pingpong-messages","title":"Ping/Pong Messages","text":"<p>Many WebSocket connections require ping/pong messages to keep the connection alive:</p> <pre><code>def parse_ws_message(self, data: dict) -&gt; Optional[List[CandleData]]:\n    \"\"\"Parse WebSocket message.\"\"\"\n    # Check if this is a ping message\n    if self._is_ping_message(data):\n        # Return a pong message that the WebSocketStrategy will send\n        return WSJSONRequest(payload=self._get_pong_payload(data))\n\n    # Continue with normal parsing...\n\ndef _is_ping_message(self, data: dict) -&gt; bool:\n    \"\"\"Check if the message is a ping request.\"\"\"\n    # Example implementation\n    return data.get(\"op\") == \"ping\"\n\ndef _get_pong_payload(self, ping_data: dict) -&gt; dict:\n    \"\"\"Create pong response from ping data.\"\"\"\n    # Example implementation\n    return {\n        \"op\": \"pong\",\n        \"ts\": ping_data.get(\"ts\", int(time.time() * 1000))\n    }\n</code></pre>"},{"location":"adapters/websocket/#websocket-message-formats","title":"WebSocket Message Formats","text":"<p>Exchanges use various formats for WebSocket messages:</p>"},{"location":"adapters/websocket/#binance-format","title":"Binance Format","text":"<pre><code>{\n  \"e\": \"kline\",\n  \"E\": 1672515782136,\n  \"s\": \"BTCUSDT\",\n  \"k\": {\n    \"t\": 1672515780000,\n    \"T\": 1672515839999,\n    \"s\": \"BTCUSDT\",\n    \"i\": \"1m\",\n    \"f\": 123456,\n    \"L\": 123457,\n    \"o\": \"16500.10\",\n    \"c\": \"16505.20\",\n    \"h\": \"16510.30\",\n    \"l\": \"16495.40\",\n    \"v\": \"5.123\",\n    \"n\": 100,\n    \"x\": false,\n    \"q\": \"84528.9\",\n    \"V\": \"2.56\",\n    \"Q\": \"42230.1\"\n  }\n}\n</code></pre>"},{"location":"adapters/websocket/#coinbase-format","title":"Coinbase Format","text":"<pre><code>{\n  \"channel\": \"candles\",\n  \"timestamp\": \"2023-01-01T00:00:00.000Z\",\n  \"events\": [\n    {\n      \"type\": \"candle\",\n      \"candles\": [\n        {\n          \"start\": \"2023-01-01T00:00:00.000Z\",\n          \"low\": \"16495.40\",\n          \"high\": \"16510.30\",\n          \"open\": \"16500.10\",\n          \"close\": \"16505.20\",\n          \"volume\": \"5.123\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"adapters/websocket/#okx-format","title":"OKX Format","text":"<pre><code>{\n  \"arg\": {\n    \"channel\": \"candle1m\",\n    \"instId\": \"BTC-USDT\"\n  },\n  \"data\": [\n    [\n      \"1672515780000\",\n      \"16500.10\",\n      \"16510.30\",\n      \"16495.40\",\n      \"16505.20\",\n      \"5.123\",\n      \"84528.9\"\n    ]\n  ]\n}\n</code></pre>"},{"location":"adapters/websocket/#websocket-error-handling","title":"WebSocket Error Handling","text":"<p>Implement robust error handling for WebSocket connections:</p> <pre><code># In your WebSocketStrategy class\nasync def _listen_for_updates(self):\n    \"\"\"Listen for WebSocket updates.\"\"\"\n    while self._running:\n        try:\n            # Establish connection\n            ws_url = self.adapter.get_ws_url()\n            self._ws_assistant = await self.network_client.establish_ws_connection(ws_url)\n\n            # Subscribe to updates\n            payload = self.adapter.get_ws_subscription_payload(self.trading_pair, self.interval)\n            await self.network_client.send_ws_message(self._ws_assistant, payload)\n\n            # Process messages\n            async for message in self._ws_assistant.iter_messages():\n                # Process message...\n\n        except ConnectionError as e:\n            logger.warning(f\"WebSocket connection error: {e}, reconnecting...\")\n            await asyncio.sleep(1.0)\n\n        except Exception as e:\n            logger.error(f\"Unexpected WebSocket error: {e}, reconnecting...\")\n            await asyncio.sleep(5.0)\n\n        finally:\n            # Clean up connection\n            if self._ws_assistant:\n                try:\n                    await self._ws_assistant.disconnect()\n                except:\n                    pass\n                self._ws_assistant = None\n</code></pre>"},{"location":"adapters/websocket/#fallback-to-rest","title":"Fallback to REST","text":"<p>For exchanges with limited WebSocket support, implement fallback to REST polling:</p> <pre><code>def get_ws_supported_intervals(self) -&gt; List[str]:\n    \"\"\"Get intervals supported by WebSocket API.\"\"\"\n    # If WebSocket doesn't support candles at all\n    return []  # Empty list means no WebSocket support\n\n    # Or for partial support\n    return [\"1m\", \"5m\"]  # Only these intervals are supported\n</code></pre> <p>The framework will automatically use REST polling for intervals not supported by WebSocket.</p>"},{"location":"adapters/websocket/#testing-websocket-integration","title":"Testing WebSocket Integration","text":"<p>Test your WebSocket implementation with these scenarios:</p> <ol> <li>Connecting and subscribing</li> <li>Handling real-time updates</li> <li>Reconnecting after disconnection</li> <li>Processing different message types (candles, heartbeats, errors)</li> <li>Fallback to REST when needed</li> </ol> <p>Example test:</p> <pre><code>def test_parse_ws_message():\n    \"\"\"Test parsing WebSocket messages.\"\"\"\n    adapter = YourExchangeAdapter()\n\n    # Sample WebSocket message\n    message = {\n        \"e\": \"kline\",\n        \"E\": 1672515782136,\n        \"s\": \"BTCUSDT\",\n        \"k\": {\n            \"t\": 1672515780000,\n            \"o\": \"16500.10\",\n            \"c\": \"16505.20\",\n            \"h\": \"16510.30\",\n            \"l\": \"16495.40\",\n            \"v\": \"5.123\"\n        }\n    }\n\n    candles = adapter.parse_ws_message(message)\n\n    assert candles is not None\n    assert len(candles) == 1\n    assert candles[0].timestamp == 1672515780\n    assert candles[0].open == 16500.10\n    assert candles[0].high == 16510.30\n    assert candles[0].low == 16495.40\n    assert candles[0].close == 16505.20\n    assert candles[0].volume == 5.123\n</code></pre>"},{"location":"adapters/websocket/#next-steps","title":"Next Steps","text":"<p>After implementing WebSocket functionality, proceed to:</p> <ul> <li>Testing Your Adapter: Comprehensive testing strategy for your adapter</li> </ul>"},{"location":"api_reference/core/","title":"Core Components API Reference","text":"<p>This page documents the core classes and functions of the Candles Feed framework.</p>"},{"location":"api_reference/core/#candlesfeed","title":"CandlesFeed","text":"<p>Main class that coordinates data collection from exchanges.</p> <p>This class is responsible for creating and managing the components needed to fetch and process candle data from exchanges.</p> Source code in <code>candles_feed/core/candles_feed.py</code> <pre><code>class CandlesFeed:\n    \"\"\"Main class that coordinates data collection from exchanges.\n\n    This class is responsible for creating and managing the components needed\n    to fetch and process candle data from exchanges.\n    \"\"\"\n\n    def __init__(\n        self,\n        exchange: str,\n        trading_pair: str,\n        interval: str = \"1m\",\n        max_records: int = 150,\n        logger: Logger | None = None,\n    ):\n        \"\"\"Initialize the candles feed.\n\n        Args:\n            exchange: Name of the exchange\n            trading_pair: Trading pair\n            interval: Candle interval\n            max_records: Maximum number of candles to store\n            logger: Logger instance\n        \"\"\"\n        self.exchange = exchange\n        self.trading_pair = trading_pair\n        self.interval = interval\n        self.max_records = max_records\n        self.logger = logger or logging.getLogger(__name__)\n\n        # Get adapter from registry\n        self._adapter = ExchangeRegistry.get_adapter_instance(exchange)\n        self.ex_trading_pair = self._adapter.get_trading_pair_format(trading_pair)\n\n        # Initialize components\n        self._candles: Deque[CandleData] = deque(maxlen=max_records)\n        self._network_client = NetworkClient()\n        self._data_processor = DataProcessor()\n\n        # Strategy attributes\n        self._rest_strategy = None\n        self._ws_strategy = None\n        self._active = False\n        self._using_ws = False\n\n    def _create_ws_strategy(self):\n        \"\"\"Create a WebSocket strategy instance.\n\n        This is a helper method that can be mocked in tests.\n        \"\"\"\n        return WebSocketStrategy(\n            network_client=self._network_client,\n            adapter=self._adapter,\n            trading_pair=self.trading_pair,\n            interval=self.interval,\n            data_processor=self._data_processor,\n            candles_store=self._candles,\n        )\n\n    def _create_rest_strategy(self):\n        \"\"\"Create a REST polling strategy instance.\n\n        This is a helper method that can be mocked in tests.\n        \"\"\"\n        return RESTPollingStrategy(\n            network_client=self._network_client,\n            adapter=self._adapter,\n            trading_pair=self.trading_pair,\n            interval=self.interval,\n            data_processor=self._data_processor,\n            candles_store=self._candles,\n        )\n\n    async def start(self, strategy: str = \"auto\") -&gt; None:\n        \"\"\"Start the feed.\n\n        Args:\n            strategy: Strategy to use (\"auto\", \"websocket\", or \"polling\")\n        \"\"\"\n        if self._active:\n            return\n\n        self.logger.info(f\"Starting candles feed for {self.trading_pair} on {self.exchange}\")\n\n        # Determine which strategy to use\n        use_websocket = False\n\n        if strategy == \"auto\":\n            # Check if the interval is supported by websocket\n            ws_intervals = self._adapter.get_ws_supported_intervals()\n            use_websocket = self.interval in ws_intervals\n        elif strategy == \"websocket\":\n            use_websocket = True\n\n        # Create and start appropriate strategy\n        if use_websocket:\n            # Only create a new strategy if one doesn't exist already (for testing)\n            if not self._ws_strategy:\n                self._ws_strategy = self._create_ws_strategy()\n\n            if not self._ws_strategy:\n                raise ValueError(\"WebSocket strategy not supported by this adapter\")\n\n            await self._ws_strategy.start()\n            self._using_ws = True\n        else:\n            # Only create a new strategy if one doesn't exist already (for testing)\n            if not self._rest_strategy:\n                self._rest_strategy = self._create_rest_strategy()\n\n            if not self._rest_strategy:\n                raise ValueError(\"WebSocket strategy not supported by this adapter\")\n\n            await self._rest_strategy.start()\n            self._using_ws = False\n\n        self._active = True\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop the feed.\"\"\"\n        if not self._active:\n            return\n\n        self.logger.info(f\"Stopping candles feed for {self.trading_pair}\")\n\n        if self._using_ws and self._ws_strategy:\n            await self._ws_strategy.stop()\n        elif self._rest_strategy:\n            await self._rest_strategy.stop()\n\n        # Clean up network client resources\n        await self._network_client.close()\n\n        self._active = False\n\n    def get_candles_df(self) -&gt; pd.DataFrame:\n        \"\"\"Get candles as a pandas DataFrame.\n\n        Returns:\n            DataFrame with candle data\n        \"\"\"\n        return pd.DataFrame(\n            [\n                {\n                    \"timestamp\": c.timestamp,\n                    \"open\": c.open,\n                    \"high\": c.high,\n                    \"low\": c.low,\n                    \"close\": c.close,\n                    \"volume\": c.volume,\n                    \"quote_asset_volume\": c.quote_asset_volume,\n                    \"n_trades\": c.n_trades,\n                    \"taker_buy_base_volume\": c.taker_buy_base_volume,\n                    \"taker_buy_quote_volume\": c.taker_buy_quote_volume,\n                }\n                for c in self._candles\n            ]\n        )\n\n    async def fetch_candles(\n        self, start_time: int | None = None, end_time: int | None = None\n    ) -&gt; list[CandleData]:\n        \"\"\"Fetch historical candles.\n\n        Args:\n            start_time: Start time in seconds (optional)\n            end_time: End time in seconds (optional)\n\n        Returns:\n            List of candle data objects\n        \"\"\"\n        self.logger.info(f\"Fetching historical candles for {self.trading_pair} on {self.exchange}\")\n\n        # Create REST strategy if it doesn't exist\n        if not self._rest_strategy:\n            self._rest_strategy = self._create_rest_strategy()\n\n        if not self._rest_strategy:\n            raise ValueError(\"REST polling strategy not supported by this adapter\")\n\n        # Fetch candles\n        candles = await self._rest_strategy.poll_once(start_time, end_time)\n\n        # Add candles to the store\n        if candles:\n            # Clear existing candles if fetching from the beginning\n            if start_time is None or (\n                len(self._candles) &gt; 0 and start_time &lt; self._candles[0].timestamp\n            ):\n                self._candles.clear()\n\n            # Add each candle to the store\n            for candle in candles:\n                self._data_processor.process_candle(candle, self._candles)\n\n        return candles\n\n    def get_candles(self) -&gt; list[CandleData]:\n        \"\"\"Get raw candle data.\n\n        Returns:\n            List of CandleData objects\n        \"\"\"\n        return list(self._candles)\n\n    def add_candle(self, candle: CandleData) -&gt; None:\n        \"\"\"Add a candle to the store.\n\n        Args:\n            candle: Candle data to add\n        \"\"\"\n        self._data_processor.process_candle(candle, self._candles)\n\n    @property\n    def ready(self) -&gt; bool:\n        \"\"\"Check if the feed is ready.\n\n        Returns:\n            True if the feed is ready, False otherwise\n        \"\"\"\n        return len(self._candles) &gt;= self.max_records * 0.9  # At least 90% filled\n\n    @property\n    def last_timestamp(self) -&gt; int | None:\n        \"\"\"Get the timestamp of the most recent candle.\n\n        Returns:\n            Timestamp in seconds, or None if no candles available\n        \"\"\"\n        return self._candles[-1].timestamp if self._candles else None\n\n    @property\n    def first_timestamp(self) -&gt; int | None:\n        \"\"\"Get the timestamp of the oldest candle.\n\n        Returns:\n            Timestamp in seconds, or None if no candles available\n        \"\"\"\n        return self._candles[0].timestamp if self._candles else None\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candles_feed.CandlesFeed.first_timestamp","title":"<code>first_timestamp</code>  <code>property</code>","text":"<p>Get the timestamp of the oldest candle.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>Timestamp in seconds, or None if no candles available</p>"},{"location":"api_reference/core/#candles_feed.core.candles_feed.CandlesFeed.last_timestamp","title":"<code>last_timestamp</code>  <code>property</code>","text":"<p>Get the timestamp of the most recent candle.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>Timestamp in seconds, or None if no candles available</p>"},{"location":"api_reference/core/#candles_feed.core.candles_feed.CandlesFeed.ready","title":"<code>ready</code>  <code>property</code>","text":"<p>Check if the feed is ready.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the feed is ready, False otherwise</p>"},{"location":"api_reference/core/#candles_feed.core.candles_feed.CandlesFeed.__init__","title":"<code>__init__(exchange, trading_pair, interval='1m', max_records=150, logger=None)</code>","text":"<p>Initialize the candles feed.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>str</code> <p>Name of the exchange</p> required <code>trading_pair</code> <code>str</code> <p>Trading pair</p> required <code>interval</code> <code>str</code> <p>Candle interval</p> <code>'1m'</code> <code>max_records</code> <code>int</code> <p>Maximum number of candles to store</p> <code>150</code> <code>logger</code> <code>Logger | None</code> <p>Logger instance</p> <code>None</code> Source code in <code>candles_feed/core/candles_feed.py</code> <pre><code>def __init__(\n    self,\n    exchange: str,\n    trading_pair: str,\n    interval: str = \"1m\",\n    max_records: int = 150,\n    logger: Logger | None = None,\n):\n    \"\"\"Initialize the candles feed.\n\n    Args:\n        exchange: Name of the exchange\n        trading_pair: Trading pair\n        interval: Candle interval\n        max_records: Maximum number of candles to store\n        logger: Logger instance\n    \"\"\"\n    self.exchange = exchange\n    self.trading_pair = trading_pair\n    self.interval = interval\n    self.max_records = max_records\n    self.logger = logger or logging.getLogger(__name__)\n\n    # Get adapter from registry\n    self._adapter = ExchangeRegistry.get_adapter_instance(exchange)\n    self.ex_trading_pair = self._adapter.get_trading_pair_format(trading_pair)\n\n    # Initialize components\n    self._candles: Deque[CandleData] = deque(maxlen=max_records)\n    self._network_client = NetworkClient()\n    self._data_processor = DataProcessor()\n\n    # Strategy attributes\n    self._rest_strategy = None\n    self._ws_strategy = None\n    self._active = False\n    self._using_ws = False\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candles_feed.CandlesFeed._create_rest_strategy","title":"<code>_create_rest_strategy()</code>","text":"<p>Create a REST polling strategy instance.</p> <p>This is a helper method that can be mocked in tests.</p> Source code in <code>candles_feed/core/candles_feed.py</code> <pre><code>def _create_rest_strategy(self):\n    \"\"\"Create a REST polling strategy instance.\n\n    This is a helper method that can be mocked in tests.\n    \"\"\"\n    return RESTPollingStrategy(\n        network_client=self._network_client,\n        adapter=self._adapter,\n        trading_pair=self.trading_pair,\n        interval=self.interval,\n        data_processor=self._data_processor,\n        candles_store=self._candles,\n    )\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candles_feed.CandlesFeed._create_ws_strategy","title":"<code>_create_ws_strategy()</code>","text":"<p>Create a WebSocket strategy instance.</p> <p>This is a helper method that can be mocked in tests.</p> Source code in <code>candles_feed/core/candles_feed.py</code> <pre><code>def _create_ws_strategy(self):\n    \"\"\"Create a WebSocket strategy instance.\n\n    This is a helper method that can be mocked in tests.\n    \"\"\"\n    return WebSocketStrategy(\n        network_client=self._network_client,\n        adapter=self._adapter,\n        trading_pair=self.trading_pair,\n        interval=self.interval,\n        data_processor=self._data_processor,\n        candles_store=self._candles,\n    )\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candles_feed.CandlesFeed.add_candle","title":"<code>add_candle(candle)</code>","text":"<p>Add a candle to the store.</p> <p>Parameters:</p> Name Type Description Default <code>candle</code> <code>CandleData</code> <p>Candle data to add</p> required Source code in <code>candles_feed/core/candles_feed.py</code> <pre><code>def add_candle(self, candle: CandleData) -&gt; None:\n    \"\"\"Add a candle to the store.\n\n    Args:\n        candle: Candle data to add\n    \"\"\"\n    self._data_processor.process_candle(candle, self._candles)\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candles_feed.CandlesFeed.fetch_candles","title":"<code>fetch_candles(start_time=None, end_time=None)</code>  <code>async</code>","text":"<p>Fetch historical candles.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>int | None</code> <p>Start time in seconds (optional)</p> <code>None</code> <code>end_time</code> <code>int | None</code> <p>End time in seconds (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[CandleData]</code> <p>List of candle data objects</p> Source code in <code>candles_feed/core/candles_feed.py</code> <pre><code>async def fetch_candles(\n    self, start_time: int | None = None, end_time: int | None = None\n) -&gt; list[CandleData]:\n    \"\"\"Fetch historical candles.\n\n    Args:\n        start_time: Start time in seconds (optional)\n        end_time: End time in seconds (optional)\n\n    Returns:\n        List of candle data objects\n    \"\"\"\n    self.logger.info(f\"Fetching historical candles for {self.trading_pair} on {self.exchange}\")\n\n    # Create REST strategy if it doesn't exist\n    if not self._rest_strategy:\n        self._rest_strategy = self._create_rest_strategy()\n\n    if not self._rest_strategy:\n        raise ValueError(\"REST polling strategy not supported by this adapter\")\n\n    # Fetch candles\n    candles = await self._rest_strategy.poll_once(start_time, end_time)\n\n    # Add candles to the store\n    if candles:\n        # Clear existing candles if fetching from the beginning\n        if start_time is None or (\n            len(self._candles) &gt; 0 and start_time &lt; self._candles[0].timestamp\n        ):\n            self._candles.clear()\n\n        # Add each candle to the store\n        for candle in candles:\n            self._data_processor.process_candle(candle, self._candles)\n\n    return candles\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candles_feed.CandlesFeed.get_candles","title":"<code>get_candles()</code>","text":"<p>Get raw candle data.</p> <p>Returns:</p> Type Description <code>list[CandleData]</code> <p>List of CandleData objects</p> Source code in <code>candles_feed/core/candles_feed.py</code> <pre><code>def get_candles(self) -&gt; list[CandleData]:\n    \"\"\"Get raw candle data.\n\n    Returns:\n        List of CandleData objects\n    \"\"\"\n    return list(self._candles)\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candles_feed.CandlesFeed.get_candles_df","title":"<code>get_candles_df()</code>","text":"<p>Get candles as a pandas DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with candle data</p> Source code in <code>candles_feed/core/candles_feed.py</code> <pre><code>def get_candles_df(self) -&gt; pd.DataFrame:\n    \"\"\"Get candles as a pandas DataFrame.\n\n    Returns:\n        DataFrame with candle data\n    \"\"\"\n    return pd.DataFrame(\n        [\n            {\n                \"timestamp\": c.timestamp,\n                \"open\": c.open,\n                \"high\": c.high,\n                \"low\": c.low,\n                \"close\": c.close,\n                \"volume\": c.volume,\n                \"quote_asset_volume\": c.quote_asset_volume,\n                \"n_trades\": c.n_trades,\n                \"taker_buy_base_volume\": c.taker_buy_base_volume,\n                \"taker_buy_quote_volume\": c.taker_buy_quote_volume,\n            }\n            for c in self._candles\n        ]\n    )\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candles_feed.CandlesFeed.start","title":"<code>start(strategy='auto')</code>  <code>async</code>","text":"<p>Start the feed.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>str</code> <p>Strategy to use (\"auto\", \"websocket\", or \"polling\")</p> <code>'auto'</code> Source code in <code>candles_feed/core/candles_feed.py</code> <pre><code>async def start(self, strategy: str = \"auto\") -&gt; None:\n    \"\"\"Start the feed.\n\n    Args:\n        strategy: Strategy to use (\"auto\", \"websocket\", or \"polling\")\n    \"\"\"\n    if self._active:\n        return\n\n    self.logger.info(f\"Starting candles feed for {self.trading_pair} on {self.exchange}\")\n\n    # Determine which strategy to use\n    use_websocket = False\n\n    if strategy == \"auto\":\n        # Check if the interval is supported by websocket\n        ws_intervals = self._adapter.get_ws_supported_intervals()\n        use_websocket = self.interval in ws_intervals\n    elif strategy == \"websocket\":\n        use_websocket = True\n\n    # Create and start appropriate strategy\n    if use_websocket:\n        # Only create a new strategy if one doesn't exist already (for testing)\n        if not self._ws_strategy:\n            self._ws_strategy = self._create_ws_strategy()\n\n        if not self._ws_strategy:\n            raise ValueError(\"WebSocket strategy not supported by this adapter\")\n\n        await self._ws_strategy.start()\n        self._using_ws = True\n    else:\n        # Only create a new strategy if one doesn't exist already (for testing)\n        if not self._rest_strategy:\n            self._rest_strategy = self._create_rest_strategy()\n\n        if not self._rest_strategy:\n            raise ValueError(\"WebSocket strategy not supported by this adapter\")\n\n        await self._rest_strategy.start()\n        self._using_ws = False\n\n    self._active = True\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candles_feed.CandlesFeed.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the feed.</p> Source code in <code>candles_feed/core/candles_feed.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the feed.\"\"\"\n    if not self._active:\n        return\n\n    self.logger.info(f\"Stopping candles feed for {self.trading_pair}\")\n\n    if self._using_ws and self._ws_strategy:\n        await self._ws_strategy.stop()\n    elif self._rest_strategy:\n        await self._rest_strategy.stop()\n\n    # Clean up network client resources\n    await self._network_client.close()\n\n    self._active = False\n</code></pre>"},{"location":"api_reference/core/#candledata","title":"CandleData","text":"<p>Standardized candle data representation.</p> <p>This class provides a structured and type-safe representation of candle data with automatic timestamp normalization.</p> <p>Attributes:</p> Name Type Description <code>timestamp</code> <code>int</code> <p>The candle timestamp in seconds</p> <code>open</code> <code>float</code> <p>Opening price</p> <code>high</code> <code>float</code> <p>Highest price during period</p> <code>low</code> <code>float</code> <p>Lowest price during period</p> <code>close</code> <code>float</code> <p>Closing price</p> <code>volume</code> <code>float</code> <p>Trading volume</p> <code>quote_asset_volume</code> <code>float</code> <p>Quote asset volume (optional)</p> <code>n_trades</code> <code>int</code> <p>Number of trades (optional)</p> <code>taker_buy_base_volume</code> <code>float</code> <p>Base asset volume from taker buys (optional)</p> <code>taker_buy_quote_volume</code> <code>float</code> <p>Quote asset volume from taker buys (optional)</p> Source code in <code>candles_feed/core/candle_data.py</code> <pre><code>@dataclass\nclass CandleData:\n    \"\"\"Standardized candle data representation.\n\n    This class provides a structured and type-safe representation of candle data\n    with automatic timestamp normalization.\n\n    Attributes:\n        timestamp: The candle timestamp in seconds\n        open: Opening price\n        high: Highest price during period\n        low: Lowest price during period\n        close: Closing price\n        volume: Trading volume\n        quote_asset_volume: Quote asset volume (optional)\n        n_trades: Number of trades (optional)\n        taker_buy_base_volume: Base asset volume from taker buys (optional)\n        taker_buy_quote_volume: Quote asset volume from taker buys (optional)\n    \"\"\"\n\n    timestamp_raw: InitVar[int | float | str | datetime]\n\n    timestamp: int = field(init=False)\n    open: float\n    high: float\n    low: float\n    close: float\n    volume: float\n    quote_asset_volume: float = 0.0\n    n_trades: int = 0\n    taker_buy_base_volume: float = 0.0\n    taker_buy_quote_volume: float = 0.0\n\n    @property\n    def timestamp_ms(self) -&gt; int:\n        \"\"\"Convert timestamp to milliseconds.\"\"\"\n        return self.timestamp * 1000\n\n    _timestamp_keys: ClassVar[tuple[str, ...]] = (\"timestamp\", \"time\", \"t\")\n    _price_keys: ClassVar[dict[str, tuple[str, ...]]] = {\n        \"open\": (\"open\", \"o\"),\n        \"high\": (\"high\", \"h\"),\n        \"low\": (\"low\", \"l\"),\n        \"close\": (\"close\", \"c\"),\n        \"volume\": (\"volume\", \"v\"),\n    }\n\n    def __post_init__(self, timestamp_raw: int | float | str | datetime) -&gt; None:\n        \"\"\"Convert timestamp to integer seconds after initialization.\n\n        Args:\n            timestamp_raw: Raw timestamp input in various formats\n        \"\"\"\n        self.timestamp = self._normalize_timestamp(timestamp_raw)\n\n    @staticmethod\n    def _normalize_timestamp(ts: int | float | str | datetime) -&gt; int:\n        \"\"\"Convert various timestamp formats to integer seconds.\n\n        Args:\n            ts: Timestamp in various formats\n\n        Returns:\n            Timestamp as integer seconds\n\n        Raises:\n            ValueError: If timestamp cannot be converted\n        \"\"\"\n        if isinstance(ts, int):\n            # Handle milliseconds/microseconds timestamps\n            if ts &gt; 10000000000:  # Likely milliseconds or microseconds\n                return ts // 1000000 if ts &gt; 10000000000000 else ts // 1000\n            return ts\n        elif isinstance(ts, float):\n            # Handle floating point timestamps (potentially with fractional seconds)\n            if ts &gt; 10000000000:  # Likely milliseconds or microseconds\n                return int(ts) // 1000000 if ts &gt; 10000000000000 else int(ts) // 1000\n            return int(ts)\n        elif isinstance(ts, str):\n            try:\n                # Try parsing as Unix timestamp first\n                return CandleData._normalize_timestamp(float(ts))\n            except ValueError:\n                try:\n                    # Try parsing as ISO format\n                    dt = datetime.fromisoformat(ts.replace(\"Z\", \"+00:00\"))\n                    return CandleData.to_utc_seconds(dt)\n                except ValueError as e:\n                    raise ValueError(f\"Could not parse timestamp string: {ts}\") from e\n        elif isinstance(ts, datetime):\n            return CandleData.to_utc_seconds(ts)\n        else:\n            raise ValueError(f\"Unsupported timestamp type: {type(ts)}\")\n\n    @staticmethod\n    def to_utc_seconds(dt: datetime) -&gt; int:\n        \"\"\"Convert datetime to UTC timestamp in seconds.\n\n        Args:\n            dt: Datetime to convert\n\n        Returns:\n            UTC timestamp in seconds\n        \"\"\"\n        if dt.tzinfo is None:\n            dt = dt.replace(tzinfo=timezone.utc)\n        return int(dt.astimezone(timezone.utc).timestamp())\n\n    def to_array(self) -&gt; list[float]:\n        \"\"\"Convert to array format for backward compatibility.\n\n        Returns:\n            List of candle values\n        \"\"\"\n        return [\n            float(self.timestamp),\n            self.open,\n            self.high,\n            self.low,\n            self.close,\n            self.volume,\n            self.quote_asset_volume,\n            self.n_trades,\n            self.taker_buy_base_volume,\n            self.taker_buy_quote_volume,\n        ]\n\n    @classmethod\n    def from_array(cls, data: list[float]) -&gt; \"CandleData\":\n        \"\"\"Create from array format for backward compatibility.\n\n        Args:\n            data: Array of candle values\n\n        Returns:\n            CandleData instance\n        \"\"\"\n        return cls(\n            timestamp_raw=data[0],\n            open=data[1],\n            high=data[2],\n            low=data[3],\n            close=data[4],\n            volume=data[5],\n            quote_asset_volume=data[6],\n            n_trades=int(data[7]),\n            taker_buy_base_volume=data[8],\n            taker_buy_quote_volume=data[9],\n        )\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"CandleData\":\n        \"\"\"Create CandleData from a dictionary.\n\n        Args:\n            data: Dictionary containing candle data\n\n        Returns:\n            CandleData instance\n\n        Raises:\n            ValueError: If required fields are missing or invalid\n        \"\"\"\n        timestamp_raw = next((data[key] for key in cls._timestamp_keys if key in data), None)\n        if timestamp_raw is None:\n            raise ValueError(f\"No timestamp found in keys: {cls._timestamp_keys}\")\n\n        # Find price values\n        values: dict[str, float | int] = {}\n        for f, keys in cls._price_keys.items():\n            value = next((float(data[key]) for key in keys if key in data), None)\n            if value is None:\n                raise ValueError(f\"No {f} value found in keys: {keys}\")\n            values[f] = value\n\n        # Return with explicit parameters instead of unpacking dictionaries\n        return cls(\n            timestamp_raw=timestamp_raw,\n            open=values[\"open\"],\n            high=values[\"high\"],\n            low=values[\"low\"],\n            close=values[\"close\"],\n            volume=values[\"volume\"],\n            quote_asset_volume=float(data.get(\"quote_asset_volume\", 0)),\n            n_trades=int(data.get(\"n_trades\", 0)),\n            taker_buy_base_volume=float(data.get(\"taker_buy_base_volume\", 0)),\n            taker_buy_quote_volume=float(data.get(\"taker_buy_quote_volume\", 0)),\n        )\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candle_data.CandleData.timestamp_ms","title":"<code>timestamp_ms</code>  <code>property</code>","text":"<p>Convert timestamp to milliseconds.</p>"},{"location":"api_reference/core/#candles_feed.core.candle_data.CandleData.__post_init__","title":"<code>__post_init__(timestamp_raw)</code>","text":"<p>Convert timestamp to integer seconds after initialization.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp_raw</code> <code>int | float | str | datetime</code> <p>Raw timestamp input in various formats</p> required Source code in <code>candles_feed/core/candle_data.py</code> <pre><code>def __post_init__(self, timestamp_raw: int | float | str | datetime) -&gt; None:\n    \"\"\"Convert timestamp to integer seconds after initialization.\n\n    Args:\n        timestamp_raw: Raw timestamp input in various formats\n    \"\"\"\n    self.timestamp = self._normalize_timestamp(timestamp_raw)\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candle_data.CandleData._normalize_timestamp","title":"<code>_normalize_timestamp(ts)</code>  <code>staticmethod</code>","text":"<p>Convert various timestamp formats to integer seconds.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>int | float | str | datetime</code> <p>Timestamp in various formats</p> required <p>Returns:</p> Type Description <code>int</code> <p>Timestamp as integer seconds</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If timestamp cannot be converted</p> Source code in <code>candles_feed/core/candle_data.py</code> <pre><code>@staticmethod\ndef _normalize_timestamp(ts: int | float | str | datetime) -&gt; int:\n    \"\"\"Convert various timestamp formats to integer seconds.\n\n    Args:\n        ts: Timestamp in various formats\n\n    Returns:\n        Timestamp as integer seconds\n\n    Raises:\n        ValueError: If timestamp cannot be converted\n    \"\"\"\n    if isinstance(ts, int):\n        # Handle milliseconds/microseconds timestamps\n        if ts &gt; 10000000000:  # Likely milliseconds or microseconds\n            return ts // 1000000 if ts &gt; 10000000000000 else ts // 1000\n        return ts\n    elif isinstance(ts, float):\n        # Handle floating point timestamps (potentially with fractional seconds)\n        if ts &gt; 10000000000:  # Likely milliseconds or microseconds\n            return int(ts) // 1000000 if ts &gt; 10000000000000 else int(ts) // 1000\n        return int(ts)\n    elif isinstance(ts, str):\n        try:\n            # Try parsing as Unix timestamp first\n            return CandleData._normalize_timestamp(float(ts))\n        except ValueError:\n            try:\n                # Try parsing as ISO format\n                dt = datetime.fromisoformat(ts.replace(\"Z\", \"+00:00\"))\n                return CandleData.to_utc_seconds(dt)\n            except ValueError as e:\n                raise ValueError(f\"Could not parse timestamp string: {ts}\") from e\n    elif isinstance(ts, datetime):\n        return CandleData.to_utc_seconds(ts)\n    else:\n        raise ValueError(f\"Unsupported timestamp type: {type(ts)}\")\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candle_data.CandleData.from_array","title":"<code>from_array(data)</code>  <code>classmethod</code>","text":"<p>Create from array format for backward compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[float]</code> <p>Array of candle values</p> required <p>Returns:</p> Type Description <code>CandleData</code> <p>CandleData instance</p> Source code in <code>candles_feed/core/candle_data.py</code> <pre><code>@classmethod\ndef from_array(cls, data: list[float]) -&gt; \"CandleData\":\n    \"\"\"Create from array format for backward compatibility.\n\n    Args:\n        data: Array of candle values\n\n    Returns:\n        CandleData instance\n    \"\"\"\n    return cls(\n        timestamp_raw=data[0],\n        open=data[1],\n        high=data[2],\n        low=data[3],\n        close=data[4],\n        volume=data[5],\n        quote_asset_volume=data[6],\n        n_trades=int(data[7]),\n        taker_buy_base_volume=data[8],\n        taker_buy_quote_volume=data[9],\n    )\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candle_data.CandleData.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create CandleData from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing candle data</p> required <p>Returns:</p> Type Description <code>CandleData</code> <p>CandleData instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required fields are missing or invalid</p> Source code in <code>candles_feed/core/candle_data.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"CandleData\":\n    \"\"\"Create CandleData from a dictionary.\n\n    Args:\n        data: Dictionary containing candle data\n\n    Returns:\n        CandleData instance\n\n    Raises:\n        ValueError: If required fields are missing or invalid\n    \"\"\"\n    timestamp_raw = next((data[key] for key in cls._timestamp_keys if key in data), None)\n    if timestamp_raw is None:\n        raise ValueError(f\"No timestamp found in keys: {cls._timestamp_keys}\")\n\n    # Find price values\n    values: dict[str, float | int] = {}\n    for f, keys in cls._price_keys.items():\n        value = next((float(data[key]) for key in keys if key in data), None)\n        if value is None:\n            raise ValueError(f\"No {f} value found in keys: {keys}\")\n        values[f] = value\n\n    # Return with explicit parameters instead of unpacking dictionaries\n    return cls(\n        timestamp_raw=timestamp_raw,\n        open=values[\"open\"],\n        high=values[\"high\"],\n        low=values[\"low\"],\n        close=values[\"close\"],\n        volume=values[\"volume\"],\n        quote_asset_volume=float(data.get(\"quote_asset_volume\", 0)),\n        n_trades=int(data.get(\"n_trades\", 0)),\n        taker_buy_base_volume=float(data.get(\"taker_buy_base_volume\", 0)),\n        taker_buy_quote_volume=float(data.get(\"taker_buy_quote_volume\", 0)),\n    )\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candle_data.CandleData.to_array","title":"<code>to_array()</code>","text":"<p>Convert to array format for backward compatibility.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>List of candle values</p> Source code in <code>candles_feed/core/candle_data.py</code> <pre><code>def to_array(self) -&gt; list[float]:\n    \"\"\"Convert to array format for backward compatibility.\n\n    Returns:\n        List of candle values\n    \"\"\"\n    return [\n        float(self.timestamp),\n        self.open,\n        self.high,\n        self.low,\n        self.close,\n        self.volume,\n        self.quote_asset_volume,\n        self.n_trades,\n        self.taker_buy_base_volume,\n        self.taker_buy_quote_volume,\n    ]\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.candle_data.CandleData.to_utc_seconds","title":"<code>to_utc_seconds(dt)</code>  <code>staticmethod</code>","text":"<p>Convert datetime to UTC timestamp in seconds.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>Datetime to convert</p> required <p>Returns:</p> Type Description <code>int</code> <p>UTC timestamp in seconds</p> Source code in <code>candles_feed/core/candle_data.py</code> <pre><code>@staticmethod\ndef to_utc_seconds(dt: datetime) -&gt; int:\n    \"\"\"Convert datetime to UTC timestamp in seconds.\n\n    Args:\n        dt: Datetime to convert\n\n    Returns:\n        UTC timestamp in seconds\n    \"\"\"\n    if dt.tzinfo is None:\n        dt = dt.replace(tzinfo=timezone.utc)\n    return int(dt.astimezone(timezone.utc).timestamp())\n</code></pre>"},{"location":"api_reference/core/#exchangeregistry","title":"ExchangeRegistry","text":"<p>Registry for exchange adapters with auto-discovery.</p> Source code in <code>candles_feed/core/exchange_registry.py</code> <pre><code>class ExchangeRegistry:\n    \"\"\"Registry for exchange adapters with auto-discovery.\"\"\"\n\n    # Use both _adapters (new API) and _registry (old API) for compatibility\n    _adapters: dict[str, type[CandleDataAdapter]] = {}\n    _registry: dict[str, type[CandleDataAdapter]] = {}\n    _logger: Logger | None = None\n\n    @classmethod\n    def logger(cls) -&gt; Logger:\n        \"\"\"Get the logger.\n\n        Returns:\n            Logger instance\n        \"\"\"\n        if cls._logger is None:\n            cls._logger = logging.getLogger(__name__)\n        return cls._logger\n\n    @classmethod\n    def register(cls, name: str):\n        \"\"\"Decorator for registering exchange adapters.\n\n        Args:\n            name: Adapter name\n\n        Returns:\n            Decorator function\n        \"\"\"\n\n        def decorator(adapter_class: type[CandleDataAdapter]):\n            cls.logger().info(f\"Registering adapter: {name}\")\n            # Register in both collections for compatibility\n            cls._adapters[name] = adapter_class\n            cls._registry[name] = adapter_class\n            return adapter_class\n\n        return decorator\n\n    @classmethod\n    def get_adapter_class(cls, name: str) -&gt; type[CandleDataAdapter]:\n        \"\"\"Get adapter class by name.\n\n        Args:\n            name: Adapter name\n\n        Returns:\n            Adapter class\n\n        Raises:\n            ValueError: If no adapter is registered with the given name\n        \"\"\"\n        adapter_class = cls._registry.get(name)\n        if adapter_class is None:\n            raise ValueError(f\"Adapter not found for exchange: {name}\")\n        return adapter_class\n\n    @classmethod\n    def get_adapter(cls, name: str) -&gt; CandleDataAdapter:\n        \"\"\"Get adapter instance by name.\n\n        Args:\n            name: Adapter name\n\n        Returns:\n            Adapter instance\n\n        Raises:\n            ValueError: If no adapter is registered with the given name\n        \"\"\"\n        adapter_class = cls.get_adapter_class(name)\n        cls.logger().debug(f\"Creating adapter instance: {name}\")\n        return adapter_class()\n\n    @classmethod\n    def get_adapter_instance(cls, name: str, *args, **kwargs) -&gt; CandleDataAdapter:\n        \"\"\"Get adapter instance by name with custom args.\n\n        Args:\n            name: Adapter name\n            *args: Positional arguments to pass to the adapter constructor\n            **kwargs: Keyword arguments to pass to the adapter constructor\n\n        Returns:\n            Adapter instance\n        \"\"\"\n        adapter_class = cls.get_adapter_class(name)\n        cls.logger().debug(f\"Creating adapter instance with args: {name}\")\n        return adapter_class(*args, **kwargs)\n\n    @classmethod\n    def get_registered_exchanges(cls) -&gt; list[str]:\n        \"\"\"Get list of registered exchange names.\n\n        Returns:\n            List of registered exchange names\n        \"\"\"\n        return list(cls._registry.keys())\n\n    @classmethod\n    def discover_adapters(cls, package_path: str | None = None) -&gt; None:\n        \"\"\"Discover and register adapters in the given package.\n\n        Args:\n            package_path: Path to package to search for adapters\n        \"\"\"\n        if package_path is None:\n            # Default to candles_feed adapters directory\n            package_path = os.path.abspath(\n                os.path.join(os.path.dirname(__file__), \"..\", \"adapters\")\n            )\n\n        cls.logger().info(f\"Discovering adapters in: {package_path}\")\n\n        # Import all modules in the package to trigger decorator registration\n        import_path = os.path.basename(os.path.dirname(package_path))\n        if import_path:\n            import_path = f\"{import_path}.\"\n        import_path += os.path.basename(package_path)\n\n        for _, name, is_pkg in pkgutil.iter_modules([package_path]):\n            if is_pkg:\n                # This is a potential exchange adapter package\n                try:\n                    cls.logger().debug(f\"Importing potential adapter: {import_path}.{name}\")\n                    importlib.import_module(f\"{import_path}.{name}\")\n                except ImportError as e:\n                    cls.logger().error(f\"Error importing {name}: {e}\")\n\n    @classmethod\n    def list_available_adapters(cls) -&gt; list[str]:\n        \"\"\"List all registered adapter names.\n\n        Returns:\n            List of adapter names\n        \"\"\"\n        return list(cls._adapters.keys())\n\n    @classmethod\n    def list_available_markets(cls) -&gt; dict[str, list[str]]:\n        \"\"\"List all available markets by adapter.\n\n        Returns:\n            Dictionary mapping adapter names to list of supported trading pairs\n        \"\"\"\n        result = {}\n        for name, adapter_class in cls._adapters.items():\n            try:\n                adapter = adapter_class()\n                # Some adapters may implement a get_available_markets method\n                if hasattr(adapter, \"get_available_markets\"):\n                    result[name] = adapter.get_available_markets()\n                else:\n                    result[name] = []\n            except Exception as e:\n                cls.logger().error(f\"Error getting markets for {name}: {e}\")\n                result[name] = []\n\n        return result\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.exchange_registry.ExchangeRegistry.discover_adapters","title":"<code>discover_adapters(package_path=None)</code>  <code>classmethod</code>","text":"<p>Discover and register adapters in the given package.</p> <p>Parameters:</p> Name Type Description Default <code>package_path</code> <code>str | None</code> <p>Path to package to search for adapters</p> <code>None</code> Source code in <code>candles_feed/core/exchange_registry.py</code> <pre><code>@classmethod\ndef discover_adapters(cls, package_path: str | None = None) -&gt; None:\n    \"\"\"Discover and register adapters in the given package.\n\n    Args:\n        package_path: Path to package to search for adapters\n    \"\"\"\n    if package_path is None:\n        # Default to candles_feed adapters directory\n        package_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), \"..\", \"adapters\")\n        )\n\n    cls.logger().info(f\"Discovering adapters in: {package_path}\")\n\n    # Import all modules in the package to trigger decorator registration\n    import_path = os.path.basename(os.path.dirname(package_path))\n    if import_path:\n        import_path = f\"{import_path}.\"\n    import_path += os.path.basename(package_path)\n\n    for _, name, is_pkg in pkgutil.iter_modules([package_path]):\n        if is_pkg:\n            # This is a potential exchange adapter package\n            try:\n                cls.logger().debug(f\"Importing potential adapter: {import_path}.{name}\")\n                importlib.import_module(f\"{import_path}.{name}\")\n            except ImportError as e:\n                cls.logger().error(f\"Error importing {name}: {e}\")\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.exchange_registry.ExchangeRegistry.get_adapter","title":"<code>get_adapter(name)</code>  <code>classmethod</code>","text":"<p>Get adapter instance by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Adapter name</p> required <p>Returns:</p> Type Description <code>CandleDataAdapter</code> <p>Adapter instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no adapter is registered with the given name</p> Source code in <code>candles_feed/core/exchange_registry.py</code> <pre><code>@classmethod\ndef get_adapter(cls, name: str) -&gt; CandleDataAdapter:\n    \"\"\"Get adapter instance by name.\n\n    Args:\n        name: Adapter name\n\n    Returns:\n        Adapter instance\n\n    Raises:\n        ValueError: If no adapter is registered with the given name\n    \"\"\"\n    adapter_class = cls.get_adapter_class(name)\n    cls.logger().debug(f\"Creating adapter instance: {name}\")\n    return adapter_class()\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.exchange_registry.ExchangeRegistry.get_adapter_class","title":"<code>get_adapter_class(name)</code>  <code>classmethod</code>","text":"<p>Get adapter class by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Adapter name</p> required <p>Returns:</p> Type Description <code>type[CandleDataAdapter]</code> <p>Adapter class</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no adapter is registered with the given name</p> Source code in <code>candles_feed/core/exchange_registry.py</code> <pre><code>@classmethod\ndef get_adapter_class(cls, name: str) -&gt; type[CandleDataAdapter]:\n    \"\"\"Get adapter class by name.\n\n    Args:\n        name: Adapter name\n\n    Returns:\n        Adapter class\n\n    Raises:\n        ValueError: If no adapter is registered with the given name\n    \"\"\"\n    adapter_class = cls._registry.get(name)\n    if adapter_class is None:\n        raise ValueError(f\"Adapter not found for exchange: {name}\")\n    return adapter_class\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.exchange_registry.ExchangeRegistry.get_adapter_instance","title":"<code>get_adapter_instance(name, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Get adapter instance by name with custom args.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Adapter name</p> required <code>*args</code> <p>Positional arguments to pass to the adapter constructor</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments to pass to the adapter constructor</p> <code>{}</code> <p>Returns:</p> Type Description <code>CandleDataAdapter</code> <p>Adapter instance</p> Source code in <code>candles_feed/core/exchange_registry.py</code> <pre><code>@classmethod\ndef get_adapter_instance(cls, name: str, *args, **kwargs) -&gt; CandleDataAdapter:\n    \"\"\"Get adapter instance by name with custom args.\n\n    Args:\n        name: Adapter name\n        *args: Positional arguments to pass to the adapter constructor\n        **kwargs: Keyword arguments to pass to the adapter constructor\n\n    Returns:\n        Adapter instance\n    \"\"\"\n    adapter_class = cls.get_adapter_class(name)\n    cls.logger().debug(f\"Creating adapter instance with args: {name}\")\n    return adapter_class(*args, **kwargs)\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.exchange_registry.ExchangeRegistry.get_registered_exchanges","title":"<code>get_registered_exchanges()</code>  <code>classmethod</code>","text":"<p>Get list of registered exchange names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of registered exchange names</p> Source code in <code>candles_feed/core/exchange_registry.py</code> <pre><code>@classmethod\ndef get_registered_exchanges(cls) -&gt; list[str]:\n    \"\"\"Get list of registered exchange names.\n\n    Returns:\n        List of registered exchange names\n    \"\"\"\n    return list(cls._registry.keys())\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.exchange_registry.ExchangeRegistry.list_available_adapters","title":"<code>list_available_adapters()</code>  <code>classmethod</code>","text":"<p>List all registered adapter names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of adapter names</p> Source code in <code>candles_feed/core/exchange_registry.py</code> <pre><code>@classmethod\ndef list_available_adapters(cls) -&gt; list[str]:\n    \"\"\"List all registered adapter names.\n\n    Returns:\n        List of adapter names\n    \"\"\"\n    return list(cls._adapters.keys())\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.exchange_registry.ExchangeRegistry.list_available_markets","title":"<code>list_available_markets()</code>  <code>classmethod</code>","text":"<p>List all available markets by adapter.</p> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Dictionary mapping adapter names to list of supported trading pairs</p> Source code in <code>candles_feed/core/exchange_registry.py</code> <pre><code>@classmethod\ndef list_available_markets(cls) -&gt; dict[str, list[str]]:\n    \"\"\"List all available markets by adapter.\n\n    Returns:\n        Dictionary mapping adapter names to list of supported trading pairs\n    \"\"\"\n    result = {}\n    for name, adapter_class in cls._adapters.items():\n        try:\n            adapter = adapter_class()\n            # Some adapters may implement a get_available_markets method\n            if hasattr(adapter, \"get_available_markets\"):\n                result[name] = adapter.get_available_markets()\n            else:\n                result[name] = []\n        except Exception as e:\n            cls.logger().error(f\"Error getting markets for {name}: {e}\")\n            result[name] = []\n\n    return result\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.exchange_registry.ExchangeRegistry.logger","title":"<code>logger()</code>  <code>classmethod</code>","text":"<p>Get the logger.</p> <p>Returns:</p> Type Description <code>Logger</code> <p>Logger instance</p> Source code in <code>candles_feed/core/exchange_registry.py</code> <pre><code>@classmethod\ndef logger(cls) -&gt; Logger:\n    \"\"\"Get the logger.\n\n    Returns:\n        Logger instance\n    \"\"\"\n    if cls._logger is None:\n        cls._logger = logging.getLogger(__name__)\n    return cls._logger\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.exchange_registry.ExchangeRegistry.register","title":"<code>register(name)</code>  <code>classmethod</code>","text":"<p>Decorator for registering exchange adapters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Adapter name</p> required <p>Returns:</p> Type Description <p>Decorator function</p> Source code in <code>candles_feed/core/exchange_registry.py</code> <pre><code>@classmethod\ndef register(cls, name: str):\n    \"\"\"Decorator for registering exchange adapters.\n\n    Args:\n        name: Adapter name\n\n    Returns:\n        Decorator function\n    \"\"\"\n\n    def decorator(adapter_class: type[CandleDataAdapter]):\n        cls.logger().info(f\"Registering adapter: {name}\")\n        # Register in both collections for compatibility\n        cls._adapters[name] = adapter_class\n        cls._registry[name] = adapter_class\n        return adapter_class\n\n    return decorator\n</code></pre>"},{"location":"api_reference/core/#networkclient","title":"NetworkClient","text":"<p>Handles network communication with exchanges.</p> <p>This class provides methods for communicating with exchange APIs, handling both REST and WebSocket connections.</p> Source code in <code>candles_feed/core/network_client.py</code> <pre><code>class NetworkClient:\n    \"\"\"Handles network communication with exchanges.\n\n    This class provides methods for communicating with exchange APIs,\n    handling both REST and WebSocket connections.\n    \"\"\"\n\n    def __init__(self, logger: Logger | None = None):\n        \"\"\"Initialize the NetworkClient.\n\n        Args:\n            logger: Logger instance\n        \"\"\"\n        self.logger: Logger = logger or logging.getLogger(__name__)\n        self._session: aiohttp.ClientSession | None = None\n\n    async def _ensure_session(self):\n        \"\"\"Ensure aiohttp session exists.\"\"\"\n        if self._session is None or self._session.closed:\n            self._session = aiohttp.ClientSession()\n\n    async def close(self):\n        \"\"\"Close the client session.\n\n        Should be called when the network client is no longer needed\n        to properly clean up resources.\n        \"\"\"\n        if self._session and not self._session.closed:\n            await self._session.close()\n            self._session = None\n\n    async def __aenter__(self):\n        \"\"\"Async context manager enter method.\"\"\"\n        await self._ensure_session()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Async context manager exit method.\"\"\"\n        await self.close()\n\n    async def get_rest_data(\n        self,\n        url: str,\n        params: dict[str, Any] | None = None,\n        data: dict[str, Any] | None = None,\n        headers: dict[str, str] | None = None,\n        method: str = \"GET\",\n    ) -&gt; Any:\n        \"\"\"Get data from REST API.\n\n        Args:\n            url: REST API URL\n            params: Query parameters\n            data: Request body data\n            headers: Request headers\n            method: HTTP method\n\n        Returns:\n            REST API response\n\n        Raises:\n            Exception: If the request fails\n        \"\"\"\n        await self._ensure_session()\n        assert self._session is not None\n\n        self.logger.debug(f\"Making REST request to {url} with params {params}\")\n\n        # Clean params, removing None values to avoid serialization issues\n        cleaned_params = None\n        if params is not None:\n            cleaned_params = {k: v for k, v in params.items() if v is not None}\n\n        # Clean data, removing None values\n        cleaned_data = None\n        if data is not None:\n            cleaned_data = {k: v for k, v in data.items() if v is not None}\n\n        try:\n            async with self._session.request(\n                method=method, url=url, params=cleaned_params, json=cleaned_data, headers=headers\n            ) as response:\n                response.raise_for_status()\n                return await response.json()\n        except Exception as e:\n            self.logger.error(f\"REST request failed: {e}\")\n            raise\n\n    async def establish_ws_connection(self, url: str) -&gt; WSAssistant:\n        \"\"\"Establish a websocket connection.\n\n        Args:\n            url: WebSocket URL\n\n        Returns:\n            WSAssistant instance\n\n        Raises:\n            Exception: If the connection fails\n        \"\"\"\n        await self._ensure_session()\n        assert self._session is not None\n\n        self.logger.debug(f\"Establishing WebSocket connection to {url}\")\n\n        try:\n            ws = await self._session.ws_connect(url=url)\n            return SimpleWSAssistant(ws, self.logger)\n        except Exception as e:\n            self.logger.error(f\"WebSocket connection failed: {e}\")\n            raise\n\n    async def send_ws_message(self, ws_assistant: WSAssistant, payload: dict[str, Any]) -&gt; None:\n        \"\"\"Send a message over WebSocket.\n\n        Args:\n            ws_assistant: WebSocket assistant\n            payload: Message payload\n\n        Raises:\n            Exception: If sending fails\n        \"\"\"\n        try:\n            await ws_assistant.send(payload)\n        except Exception as e:\n            self.logger.error(f\"Failed to send WebSocket message: {e}\")\n            raise\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_client.NetworkClient.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async context manager enter method.</p> Source code in <code>candles_feed/core/network_client.py</code> <pre><code>async def __aenter__(self):\n    \"\"\"Async context manager enter method.\"\"\"\n    await self._ensure_session()\n    return self\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_client.NetworkClient.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async context manager exit method.</p> Source code in <code>candles_feed/core/network_client.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Async context manager exit method.\"\"\"\n    await self.close()\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_client.NetworkClient.__init__","title":"<code>__init__(logger=None)</code>","text":"<p>Initialize the NetworkClient.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger | None</code> <p>Logger instance</p> <code>None</code> Source code in <code>candles_feed/core/network_client.py</code> <pre><code>def __init__(self, logger: Logger | None = None):\n    \"\"\"Initialize the NetworkClient.\n\n    Args:\n        logger: Logger instance\n    \"\"\"\n    self.logger: Logger = logger or logging.getLogger(__name__)\n    self._session: aiohttp.ClientSession | None = None\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_client.NetworkClient._ensure_session","title":"<code>_ensure_session()</code>  <code>async</code>","text":"<p>Ensure aiohttp session exists.</p> Source code in <code>candles_feed/core/network_client.py</code> <pre><code>async def _ensure_session(self):\n    \"\"\"Ensure aiohttp session exists.\"\"\"\n    if self._session is None or self._session.closed:\n        self._session = aiohttp.ClientSession()\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_client.NetworkClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the client session.</p> <p>Should be called when the network client is no longer needed to properly clean up resources.</p> Source code in <code>candles_feed/core/network_client.py</code> <pre><code>async def close(self):\n    \"\"\"Close the client session.\n\n    Should be called when the network client is no longer needed\n    to properly clean up resources.\n    \"\"\"\n    if self._session and not self._session.closed:\n        await self._session.close()\n        self._session = None\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_client.NetworkClient.establish_ws_connection","title":"<code>establish_ws_connection(url)</code>  <code>async</code>","text":"<p>Establish a websocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>WebSocket URL</p> required <p>Returns:</p> Type Description <code>WSAssistant</code> <p>WSAssistant instance</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the connection fails</p> Source code in <code>candles_feed/core/network_client.py</code> <pre><code>async def establish_ws_connection(self, url: str) -&gt; WSAssistant:\n    \"\"\"Establish a websocket connection.\n\n    Args:\n        url: WebSocket URL\n\n    Returns:\n        WSAssistant instance\n\n    Raises:\n        Exception: If the connection fails\n    \"\"\"\n    await self._ensure_session()\n    assert self._session is not None\n\n    self.logger.debug(f\"Establishing WebSocket connection to {url}\")\n\n    try:\n        ws = await self._session.ws_connect(url=url)\n        return SimpleWSAssistant(ws, self.logger)\n    except Exception as e:\n        self.logger.error(f\"WebSocket connection failed: {e}\")\n        raise\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_client.NetworkClient.get_rest_data","title":"<code>get_rest_data(url, params=None, data=None, headers=None, method='GET')</code>  <code>async</code>","text":"<p>Get data from REST API.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>REST API URL</p> required <code>params</code> <code>dict[str, Any] | None</code> <p>Query parameters</p> <code>None</code> <code>data</code> <code>dict[str, Any] | None</code> <p>Request body data</p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>Request headers</p> <code>None</code> <code>method</code> <code>str</code> <p>HTTP method</p> <code>'GET'</code> <p>Returns:</p> Type Description <code>Any</code> <p>REST API response</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the request fails</p> Source code in <code>candles_feed/core/network_client.py</code> <pre><code>async def get_rest_data(\n    self,\n    url: str,\n    params: dict[str, Any] | None = None,\n    data: dict[str, Any] | None = None,\n    headers: dict[str, str] | None = None,\n    method: str = \"GET\",\n) -&gt; Any:\n    \"\"\"Get data from REST API.\n\n    Args:\n        url: REST API URL\n        params: Query parameters\n        data: Request body data\n        headers: Request headers\n        method: HTTP method\n\n    Returns:\n        REST API response\n\n    Raises:\n        Exception: If the request fails\n    \"\"\"\n    await self._ensure_session()\n    assert self._session is not None\n\n    self.logger.debug(f\"Making REST request to {url} with params {params}\")\n\n    # Clean params, removing None values to avoid serialization issues\n    cleaned_params = None\n    if params is not None:\n        cleaned_params = {k: v for k, v in params.items() if v is not None}\n\n    # Clean data, removing None values\n    cleaned_data = None\n    if data is not None:\n        cleaned_data = {k: v for k, v in data.items() if v is not None}\n\n    try:\n        async with self._session.request(\n            method=method, url=url, params=cleaned_params, json=cleaned_data, headers=headers\n        ) as response:\n            response.raise_for_status()\n            return await response.json()\n    except Exception as e:\n        self.logger.error(f\"REST request failed: {e}\")\n        raise\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_client.NetworkClient.send_ws_message","title":"<code>send_ws_message(ws_assistant, payload)</code>  <code>async</code>","text":"<p>Send a message over WebSocket.</p> <p>Parameters:</p> Name Type Description Default <code>ws_assistant</code> <code>WSAssistant</code> <p>WebSocket assistant</p> required <code>payload</code> <code>dict[str, Any]</code> <p>Message payload</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If sending fails</p> Source code in <code>candles_feed/core/network_client.py</code> <pre><code>async def send_ws_message(self, ws_assistant: WSAssistant, payload: dict[str, Any]) -&gt; None:\n    \"\"\"Send a message over WebSocket.\n\n    Args:\n        ws_assistant: WebSocket assistant\n        payload: Message payload\n\n    Raises:\n        Exception: If sending fails\n    \"\"\"\n    try:\n        await ws_assistant.send(payload)\n    except Exception as e:\n        self.logger.error(f\"Failed to send WebSocket message: {e}\")\n        raise\n</code></pre>"},{"location":"api_reference/core/#networkstrategies","title":"NetworkStrategies","text":""},{"location":"api_reference/core/#websocketstrategy","title":"WebSocketStrategy","text":"<p>Implementation for websocket-based candle retrieval.</p> Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>class WebSocketStrategy:\n    \"\"\"Implementation for websocket-based candle retrieval.\"\"\"\n\n    def __init__(\n        self,\n        network_client: NetworkClient,\n        adapter: CandleDataAdapter,\n        trading_pair: str,\n        interval: str,\n        data_processor: DataProcessor,\n        candles_store: Deque[CandleData],\n        logger: Logger | None = None,\n    ):\n        \"\"\"Initialize the WebSocketStrategy.\n\n        Args:\n            network_client: Network client for API communication\n            adapter: Exchange adapter\n            trading_pair: Trading pair\n            interval: Candle interval\n            data_processor: Data processor\n            candles_store: Deque for storing candles\n            logger: Logger instance\n        \"\"\"\n        self.network_client = network_client\n        self.adapter = adapter\n        self.trading_pair = trading_pair\n        self.interval = interval\n        self.data_processor = data_processor\n        self._candles = candles_store\n        self.logger = logger or logging.getLogger(__name__)\n        self._ws_assistant: WSAssistant | None = None\n        self._listen_task: asyncio.Task | None = None\n        self._running = False\n        self._ready_event = asyncio.Event()\n\n    async def start(self) -&gt; None:\n        \"\"\"Start listening for websocket updates.\"\"\"\n        if not self._running:\n            self._running = True\n            self._listen_task = asyncio.create_task(self._listen_for_updates())\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop listening for websocket updates.\"\"\"\n        self._running = False\n\n        if self._listen_task:\n            self._listen_task.cancel()\n            self._listen_task = None\n\n        if self._ws_assistant:\n            await self._ws_assistant.disconnect()\n            self._ws_assistant = None\n\n    async def poll_once(\n        self,\n        start_time: int | None = None,\n        end_time: int | None = None,\n        limit: int | None = None,\n    ) -&gt; list[CandleData]:\n        \"\"\"\n        Fetch candles for a specific time range (one-time poll).\n\n        For WebSocket strategy, this falls back to REST API for historical data.\n\n        Args:\n            start_time: Start time in seconds\n            end_time: End time in seconds\n            limit: Maximum number of candles to return\n\n        Returns:\n            List of CandleData objects\n        \"\"\"\n        # For historical data, we need to use REST API\n        url = self.adapter.get_rest_url()\n        params = self.adapter.get_rest_params(\n            trading_pair=self.trading_pair,\n            interval=self.interval,\n            start_time=start_time,\n            end_time=end_time,\n            limit=limit,\n        )\n\n        try:\n            response = await self.network_client.get_rest_data(url=url, params=params)\n\n            candles = self.adapter.parse_rest_response(response)\n            interval_seconds = self.adapter.get_supported_intervals()[self.interval]\n\n            processed_candles = self.data_processor.sanitize_candles(candles, interval_seconds)\n\n            return processed_candles\n\n        except Exception as e:\n            self.logger.error(f\"Error fetching candles via REST: {e}\")\n            return []\n\n    async def _listen_for_updates(self) -&gt; None:\n        \"\"\"Listen for websocket updates.\"\"\"\n        # If we have no initial data, fetch it via REST API\n        if not self._candles:\n            await self._initialize_candles()\n        else:\n            self._ready_event.set()\n\n        while self._running:\n            try:\n                ws_url = self.adapter.get_ws_url()\n                self._ws_assistant = await self.network_client.establish_ws_connection(ws_url)\n\n                # Subscribe to candle updates\n                payload = self.adapter.get_ws_subscription_payload(self.trading_pair, self.interval)\n                await self.network_client.send_ws_message(self._ws_assistant, payload)\n\n                # Process incoming messages\n                async for message in self._ws_assistant.iter_messages():\n                    if not self._running:\n                        break\n\n                    candles = self.adapter.parse_ws_message(message)\n                    if candles:\n                        interval_seconds = self.adapter.get_supported_intervals()[self.interval]\n                        validated_candles = self.data_processor.sanitize_candles(\n                            candles, interval_seconds\n                        )\n                        self._update_candles(validated_candles)\n\n            except asyncio.CancelledError:\n                raise\n            except Exception as e:\n                self.logger.exception(f\"Error in websocket connection: {e}\")\n                # If we have a connection, try to disconnect\n                if self._ws_assistant:\n                    try:\n                        await self._ws_assistant.disconnect()\n                    except Exception:  # Use explicit Exception instead of bare except\n                        pass\n                    finally:\n                        self._ws_assistant = None\n\n                if self._running:\n                    await asyncio.sleep(1.0)\n\n    async def _initialize_candles(self) -&gt; None:\n        \"\"\"Initialize candles using REST API.\"\"\"\n        try:\n            # Get enough candles to fill the store\n            limit = self._candles.maxlen\n            candles = await self.poll_once(limit=limit)\n            if candles:\n                for candle in candles:\n                    self._candles.append(candle)\n                self._ready_event.set()\n            else:\n                self.logger.warning(\"Failed to initialize candles, will retry\")\n        except Exception as e:\n            self.logger.error(f\"Error initializing candles: {e}\")\n\n    def _update_candles(self, new_candles: list[CandleData]) -&gt; None:\n        \"\"\"Update the candles store with new data.\n\n        Args:\n            new_candles: New candles to update\n        \"\"\"\n        if not new_candles:\n            return\n\n        # Either update existing candle or append new one\n        for candle in new_candles:\n            self.data_processor.process_candle(candle, self._candles)\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_strategies.WebSocketStrategy.__init__","title":"<code>__init__(network_client, adapter, trading_pair, interval, data_processor, candles_store, logger=None)</code>","text":"<p>Initialize the WebSocketStrategy.</p> <p>Parameters:</p> Name Type Description Default <code>network_client</code> <code>NetworkClient</code> <p>Network client for API communication</p> required <code>adapter</code> <code>CandleDataAdapter</code> <p>Exchange adapter</p> required <code>trading_pair</code> <code>str</code> <p>Trading pair</p> required <code>interval</code> <code>str</code> <p>Candle interval</p> required <code>data_processor</code> <code>DataProcessor</code> <p>Data processor</p> required <code>candles_store</code> <code>Deque[CandleData]</code> <p>Deque for storing candles</p> required <code>logger</code> <code>Logger | None</code> <p>Logger instance</p> <code>None</code> Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>def __init__(\n    self,\n    network_client: NetworkClient,\n    adapter: CandleDataAdapter,\n    trading_pair: str,\n    interval: str,\n    data_processor: DataProcessor,\n    candles_store: Deque[CandleData],\n    logger: Logger | None = None,\n):\n    \"\"\"Initialize the WebSocketStrategy.\n\n    Args:\n        network_client: Network client for API communication\n        adapter: Exchange adapter\n        trading_pair: Trading pair\n        interval: Candle interval\n        data_processor: Data processor\n        candles_store: Deque for storing candles\n        logger: Logger instance\n    \"\"\"\n    self.network_client = network_client\n    self.adapter = adapter\n    self.trading_pair = trading_pair\n    self.interval = interval\n    self.data_processor = data_processor\n    self._candles = candles_store\n    self.logger = logger or logging.getLogger(__name__)\n    self._ws_assistant: WSAssistant | None = None\n    self._listen_task: asyncio.Task | None = None\n    self._running = False\n    self._ready_event = asyncio.Event()\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_strategies.WebSocketStrategy._initialize_candles","title":"<code>_initialize_candles()</code>  <code>async</code>","text":"<p>Initialize candles using REST API.</p> Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>async def _initialize_candles(self) -&gt; None:\n    \"\"\"Initialize candles using REST API.\"\"\"\n    try:\n        # Get enough candles to fill the store\n        limit = self._candles.maxlen\n        candles = await self.poll_once(limit=limit)\n        if candles:\n            for candle in candles:\n                self._candles.append(candle)\n            self._ready_event.set()\n        else:\n            self.logger.warning(\"Failed to initialize candles, will retry\")\n    except Exception as e:\n        self.logger.error(f\"Error initializing candles: {e}\")\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_strategies.WebSocketStrategy._listen_for_updates","title":"<code>_listen_for_updates()</code>  <code>async</code>","text":"<p>Listen for websocket updates.</p> Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>async def _listen_for_updates(self) -&gt; None:\n    \"\"\"Listen for websocket updates.\"\"\"\n    # If we have no initial data, fetch it via REST API\n    if not self._candles:\n        await self._initialize_candles()\n    else:\n        self._ready_event.set()\n\n    while self._running:\n        try:\n            ws_url = self.adapter.get_ws_url()\n            self._ws_assistant = await self.network_client.establish_ws_connection(ws_url)\n\n            # Subscribe to candle updates\n            payload = self.adapter.get_ws_subscription_payload(self.trading_pair, self.interval)\n            await self.network_client.send_ws_message(self._ws_assistant, payload)\n\n            # Process incoming messages\n            async for message in self._ws_assistant.iter_messages():\n                if not self._running:\n                    break\n\n                candles = self.adapter.parse_ws_message(message)\n                if candles:\n                    interval_seconds = self.adapter.get_supported_intervals()[self.interval]\n                    validated_candles = self.data_processor.sanitize_candles(\n                        candles, interval_seconds\n                    )\n                    self._update_candles(validated_candles)\n\n        except asyncio.CancelledError:\n            raise\n        except Exception as e:\n            self.logger.exception(f\"Error in websocket connection: {e}\")\n            # If we have a connection, try to disconnect\n            if self._ws_assistant:\n                try:\n                    await self._ws_assistant.disconnect()\n                except Exception:  # Use explicit Exception instead of bare except\n                    pass\n                finally:\n                    self._ws_assistant = None\n\n            if self._running:\n                await asyncio.sleep(1.0)\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_strategies.WebSocketStrategy._update_candles","title":"<code>_update_candles(new_candles)</code>","text":"<p>Update the candles store with new data.</p> <p>Parameters:</p> Name Type Description Default <code>new_candles</code> <code>list[CandleData]</code> <p>New candles to update</p> required Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>def _update_candles(self, new_candles: list[CandleData]) -&gt; None:\n    \"\"\"Update the candles store with new data.\n\n    Args:\n        new_candles: New candles to update\n    \"\"\"\n    if not new_candles:\n        return\n\n    # Either update existing candle or append new one\n    for candle in new_candles:\n        self.data_processor.process_candle(candle, self._candles)\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_strategies.WebSocketStrategy.poll_once","title":"<code>poll_once(start_time=None, end_time=None, limit=None)</code>  <code>async</code>","text":"<p>Fetch candles for a specific time range (one-time poll).</p> <p>For WebSocket strategy, this falls back to REST API for historical data.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>int | None</code> <p>Start time in seconds</p> <code>None</code> <code>end_time</code> <code>int | None</code> <p>End time in seconds</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of candles to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[CandleData]</code> <p>List of CandleData objects</p> Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>async def poll_once(\n    self,\n    start_time: int | None = None,\n    end_time: int | None = None,\n    limit: int | None = None,\n) -&gt; list[CandleData]:\n    \"\"\"\n    Fetch candles for a specific time range (one-time poll).\n\n    For WebSocket strategy, this falls back to REST API for historical data.\n\n    Args:\n        start_time: Start time in seconds\n        end_time: End time in seconds\n        limit: Maximum number of candles to return\n\n    Returns:\n        List of CandleData objects\n    \"\"\"\n    # For historical data, we need to use REST API\n    url = self.adapter.get_rest_url()\n    params = self.adapter.get_rest_params(\n        trading_pair=self.trading_pair,\n        interval=self.interval,\n        start_time=start_time,\n        end_time=end_time,\n        limit=limit,\n    )\n\n    try:\n        response = await self.network_client.get_rest_data(url=url, params=params)\n\n        candles = self.adapter.parse_rest_response(response)\n        interval_seconds = self.adapter.get_supported_intervals()[self.interval]\n\n        processed_candles = self.data_processor.sanitize_candles(candles, interval_seconds)\n\n        return processed_candles\n\n    except Exception as e:\n        self.logger.error(f\"Error fetching candles via REST: {e}\")\n        return []\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_strategies.WebSocketStrategy.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start listening for websocket updates.</p> Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start listening for websocket updates.\"\"\"\n    if not self._running:\n        self._running = True\n        self._listen_task = asyncio.create_task(self._listen_for_updates())\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_strategies.WebSocketStrategy.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop listening for websocket updates.</p> Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop listening for websocket updates.\"\"\"\n    self._running = False\n\n    if self._listen_task:\n        self._listen_task.cancel()\n        self._listen_task = None\n\n    if self._ws_assistant:\n        await self._ws_assistant.disconnect()\n        self._ws_assistant = None\n</code></pre>"},{"location":"api_reference/core/#restpollingstrategy","title":"RESTPollingStrategy","text":"<p>Implementation for REST-based polling candle retrieval.</p> Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>class RESTPollingStrategy:\n    \"\"\"Implementation for REST-based polling candle retrieval.\"\"\"\n\n    def __init__(\n        self,\n        network_client: NetworkClient,\n        adapter: CandleDataAdapter,\n        trading_pair: str,\n        interval: str,\n        data_processor: DataProcessor,\n        candles_store: Deque[CandleData],\n        logger: Logger | None = None,\n    ):\n        \"\"\"Initialize the RESTPollingStrategy.\n\n        Args:\n            network_client: Network client for API communication\n            adapter: Exchange adapter\n            trading_pair: Trading pair\n            interval: Candle interval\n            data_processor: Data processor\n            candles_store: Deque for storing candles\n            logger: Logger instance\n        \"\"\"\n        self.network_client = network_client\n        self.adapter = adapter\n        self.trading_pair = trading_pair\n        self.interval = interval\n        self.data_processor = data_processor\n        self._candles = candles_store\n        self.logger = logger or logging.getLogger(__name__)\n        self._polling_task: asyncio.Task | None = None\n        self._polling_interval = adapter.get_supported_intervals()[interval]\n        self._running = False\n        self._ready_event = asyncio.Event()\n\n    async def start(self) -&gt; None:\n        \"\"\"Start polling for updates.\"\"\"\n        if not self._running:\n            self._running = True\n            self._polling_task = asyncio.create_task(self._poll_for_updates())\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop polling for updates.\"\"\"\n        self._running = False\n        if self._polling_task:\n            self._polling_task.cancel()\n            self._polling_task = None\n\n        # Make sure we clean up any remaining network resources\n        # The parent CandlesFeed class will close the network client\n\n    async def poll_once(\n        self,\n        start_time: int | None = None,\n        end_time: int | None = None,\n        limit: int | None = None,\n    ) -&gt; list[CandleData]:\n        \"\"\"Fetch candles for a specific time range (one-time poll).\n\n        Args:\n            start_time: Start time in seconds\n            end_time: End time in seconds\n            limit: Maximum number of candles to return\n\n        Returns:\n            List of CandleData objects\n        \"\"\"\n        try:\n            # Adjust start/end time to align with intervals\n            interval_seconds = self.adapter.get_supported_intervals()[self.interval]\n\n            # Calculate proper parameters\n            if end_time is None:\n                end_time = int(time.time())\n\n            # Round down to nearest interval\n            end_time = end_time - (end_time % interval_seconds)\n\n            if start_time is None and limit is not None:\n                start_time = end_time - (limit * interval_seconds)\n            elif start_time is not None:\n                start_time = start_time - (start_time % interval_seconds)\n\n            # Get REST parameters from adapter\n            params = self.adapter.get_rest_params(\n                trading_pair=self.trading_pair,\n                interval=self.interval,\n                start_time=start_time,\n                end_time=end_time,\n                limit=limit,\n            )\n\n            # Execute request\n            url = self.adapter.get_rest_url()\n            response = await self.network_client.get_rest_data(url=url, params=params)\n\n            # Parse and process response\n            candles = self.adapter.parse_rest_response(response)\n            return self.data_processor.sanitize_candles(candles, interval_seconds)\n\n        except Exception as e:\n            self.logger.exception(f\"Error fetching candles: {e}\")\n            return []\n\n    async def _poll_for_updates(self) -&gt; None:\n        \"\"\"Poll for updates at regular intervals.\"\"\"\n        # Initial fetch to populate the store\n        if not self._candles:\n            initial_candles = await self.poll_once(limit=self._candles.maxlen)\n            if initial_candles:\n                # Add all candles to the store\n                for candle in initial_candles:\n                    self._candles.append(candle)\n                self._ready_event.set()\n        else:\n            self._ready_event.set()\n\n        while self._running:\n            try:\n                # Calculate parameters for incremental updates\n                if self._candles:\n                    # Get data since the last candle, excluding the last one\n                    # which might be incomplete\n                    if len(self._candles) &gt; 1:\n                        # If we have more than one candle, we can safely slice\n                        candles_without_last = list(self._candles)[:-1]\n                        last_complete_ts = max(c.timestamp for c in candles_without_last)\n                    else:\n                        # If we have only one candle, use its timestamp as starting point\n                        last_complete_ts = self._candles[0].timestamp\n\n                    # Fetch new or updated candles\n                    candles = await self.poll_once(start_time=last_complete_ts)\n                    self._update_candles(candles)\n\n                # Sleep until next interval\n                sleep_time = max(\n                    self._polling_interval / 2, 1\n                )  # At least 1s, but prefer half interval\n                await asyncio.sleep(sleep_time)\n\n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                self.logger.exception(f\"Error in polling loop: {e}\")\n                await asyncio.sleep(1.0)\n\n    def _update_candles(self, new_candles: list[CandleData]) -&gt; None:\n        \"\"\"Update the candles store with new data.\n\n        Args:\n            new_candles: New candles to update\n        \"\"\"\n        if not new_candles:\n            return\n\n        for candle in new_candles:\n            self.data_processor.process_candle(candle, self._candles)\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_strategies.RESTPollingStrategy.__init__","title":"<code>__init__(network_client, adapter, trading_pair, interval, data_processor, candles_store, logger=None)</code>","text":"<p>Initialize the RESTPollingStrategy.</p> <p>Parameters:</p> Name Type Description Default <code>network_client</code> <code>NetworkClient</code> <p>Network client for API communication</p> required <code>adapter</code> <code>CandleDataAdapter</code> <p>Exchange adapter</p> required <code>trading_pair</code> <code>str</code> <p>Trading pair</p> required <code>interval</code> <code>str</code> <p>Candle interval</p> required <code>data_processor</code> <code>DataProcessor</code> <p>Data processor</p> required <code>candles_store</code> <code>Deque[CandleData]</code> <p>Deque for storing candles</p> required <code>logger</code> <code>Logger | None</code> <p>Logger instance</p> <code>None</code> Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>def __init__(\n    self,\n    network_client: NetworkClient,\n    adapter: CandleDataAdapter,\n    trading_pair: str,\n    interval: str,\n    data_processor: DataProcessor,\n    candles_store: Deque[CandleData],\n    logger: Logger | None = None,\n):\n    \"\"\"Initialize the RESTPollingStrategy.\n\n    Args:\n        network_client: Network client for API communication\n        adapter: Exchange adapter\n        trading_pair: Trading pair\n        interval: Candle interval\n        data_processor: Data processor\n        candles_store: Deque for storing candles\n        logger: Logger instance\n    \"\"\"\n    self.network_client = network_client\n    self.adapter = adapter\n    self.trading_pair = trading_pair\n    self.interval = interval\n    self.data_processor = data_processor\n    self._candles = candles_store\n    self.logger = logger or logging.getLogger(__name__)\n    self._polling_task: asyncio.Task | None = None\n    self._polling_interval = adapter.get_supported_intervals()[interval]\n    self._running = False\n    self._ready_event = asyncio.Event()\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_strategies.RESTPollingStrategy._poll_for_updates","title":"<code>_poll_for_updates()</code>  <code>async</code>","text":"<p>Poll for updates at regular intervals.</p> Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>async def _poll_for_updates(self) -&gt; None:\n    \"\"\"Poll for updates at regular intervals.\"\"\"\n    # Initial fetch to populate the store\n    if not self._candles:\n        initial_candles = await self.poll_once(limit=self._candles.maxlen)\n        if initial_candles:\n            # Add all candles to the store\n            for candle in initial_candles:\n                self._candles.append(candle)\n            self._ready_event.set()\n    else:\n        self._ready_event.set()\n\n    while self._running:\n        try:\n            # Calculate parameters for incremental updates\n            if self._candles:\n                # Get data since the last candle, excluding the last one\n                # which might be incomplete\n                if len(self._candles) &gt; 1:\n                    # If we have more than one candle, we can safely slice\n                    candles_without_last = list(self._candles)[:-1]\n                    last_complete_ts = max(c.timestamp for c in candles_without_last)\n                else:\n                    # If we have only one candle, use its timestamp as starting point\n                    last_complete_ts = self._candles[0].timestamp\n\n                # Fetch new or updated candles\n                candles = await self.poll_once(start_time=last_complete_ts)\n                self._update_candles(candles)\n\n            # Sleep until next interval\n            sleep_time = max(\n                self._polling_interval / 2, 1\n            )  # At least 1s, but prefer half interval\n            await asyncio.sleep(sleep_time)\n\n        except asyncio.CancelledError:\n            break\n        except Exception as e:\n            self.logger.exception(f\"Error in polling loop: {e}\")\n            await asyncio.sleep(1.0)\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_strategies.RESTPollingStrategy._update_candles","title":"<code>_update_candles(new_candles)</code>","text":"<p>Update the candles store with new data.</p> <p>Parameters:</p> Name Type Description Default <code>new_candles</code> <code>list[CandleData]</code> <p>New candles to update</p> required Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>def _update_candles(self, new_candles: list[CandleData]) -&gt; None:\n    \"\"\"Update the candles store with new data.\n\n    Args:\n        new_candles: New candles to update\n    \"\"\"\n    if not new_candles:\n        return\n\n    for candle in new_candles:\n        self.data_processor.process_candle(candle, self._candles)\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_strategies.RESTPollingStrategy.poll_once","title":"<code>poll_once(start_time=None, end_time=None, limit=None)</code>  <code>async</code>","text":"<p>Fetch candles for a specific time range (one-time poll).</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>int | None</code> <p>Start time in seconds</p> <code>None</code> <code>end_time</code> <code>int | None</code> <p>End time in seconds</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of candles to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[CandleData]</code> <p>List of CandleData objects</p> Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>async def poll_once(\n    self,\n    start_time: int | None = None,\n    end_time: int | None = None,\n    limit: int | None = None,\n) -&gt; list[CandleData]:\n    \"\"\"Fetch candles for a specific time range (one-time poll).\n\n    Args:\n        start_time: Start time in seconds\n        end_time: End time in seconds\n        limit: Maximum number of candles to return\n\n    Returns:\n        List of CandleData objects\n    \"\"\"\n    try:\n        # Adjust start/end time to align with intervals\n        interval_seconds = self.adapter.get_supported_intervals()[self.interval]\n\n        # Calculate proper parameters\n        if end_time is None:\n            end_time = int(time.time())\n\n        # Round down to nearest interval\n        end_time = end_time - (end_time % interval_seconds)\n\n        if start_time is None and limit is not None:\n            start_time = end_time - (limit * interval_seconds)\n        elif start_time is not None:\n            start_time = start_time - (start_time % interval_seconds)\n\n        # Get REST parameters from adapter\n        params = self.adapter.get_rest_params(\n            trading_pair=self.trading_pair,\n            interval=self.interval,\n            start_time=start_time,\n            end_time=end_time,\n            limit=limit,\n        )\n\n        # Execute request\n        url = self.adapter.get_rest_url()\n        response = await self.network_client.get_rest_data(url=url, params=params)\n\n        # Parse and process response\n        candles = self.adapter.parse_rest_response(response)\n        return self.data_processor.sanitize_candles(candles, interval_seconds)\n\n    except Exception as e:\n        self.logger.exception(f\"Error fetching candles: {e}\")\n        return []\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_strategies.RESTPollingStrategy.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start polling for updates.</p> Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start polling for updates.\"\"\"\n    if not self._running:\n        self._running = True\n        self._polling_task = asyncio.create_task(self._poll_for_updates())\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.network_strategies.RESTPollingStrategy.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop polling for updates.</p> Source code in <code>candles_feed/core/network_strategies.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop polling for updates.\"\"\"\n    self._running = False\n    if self._polling_task:\n        self._polling_task.cancel()\n        self._polling_task = None\n</code></pre>"},{"location":"api_reference/core/#protocols","title":"Protocols","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for exchange adapters.</p> <p>This protocol defines the interface that all exchange adapters must implement.</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>@runtime_checkable\nclass CandleDataAdapter(Protocol):\n    \"\"\"Protocol for exchange adapters.\n\n    This protocol defines the interface that all exchange adapters must implement.\n    \"\"\"\n\n    def get_trading_pair_format(self, trading_pair: str) -&gt; str:\n        \"\"\"Convert standard trading pair format to exchange format.\n\n        Args:\n            trading_pair: Trading pair in standard format (e.g., \"BTC-USDT\")\n\n        Returns:\n            Trading pair in exchange-specific format\n        \"\"\"\n        ...\n\n    def get_rest_url(self) -&gt; str:\n        \"\"\"Get REST API URL for candles.\n\n        Returns:\n            REST API URL\n        \"\"\"\n        ...\n\n    def get_ws_url(self) -&gt; str:\n        \"\"\"Get WebSocket URL.\n\n        Returns:\n            WebSocket URL\n        \"\"\"\n        ...\n\n    def get_rest_params(\n        self,\n        trading_pair: str,\n        interval: str,\n        start_time: int | None = None,\n        end_time: int | None = None,\n        limit: int | None = None,\n    ) -&gt; dict:\n        \"\"\"Get parameters for REST API request.\n\n        Args:\n            trading_pair: Trading pair\n            interval: Candle interval\n            start_time: Start time in seconds\n            end_time: End time in seconds\n            limit: Maximum number of candles to return\n\n        Returns:\n            Dictionary of parameters for REST API request\n        \"\"\"\n        ...\n\n    def parse_rest_response(self, data: Any) -&gt; list[CandleData]:\n        \"\"\"Parse REST API response into CandleData objects.\n\n        Args:\n            data: REST API response\n\n        Returns:\n            List of CandleData objects\n        \"\"\"\n        ...\n\n    def get_ws_subscription_payload(self, trading_pair: str, interval: str) -&gt; dict:\n        \"\"\"Get WebSocket subscription payload.\n\n        Args:\n            trading_pair: Trading pair\n            interval: Candle interval\n\n        Returns:\n            WebSocket subscription payload\n        \"\"\"\n        ...\n\n    def parse_ws_message(self, data: Any) -&gt; list[CandleData] | None:\n        \"\"\"Parse WebSocket message into CandleData objects.\n\n        Args:\n            data: WebSocket message\n\n        Returns:\n            List of CandleData objects or None if message is not a candle update\n        \"\"\"\n        ...\n\n    def get_supported_intervals(self) -&gt; dict[str, int]:\n        \"\"\"Get supported intervals and their durations in seconds.\n\n        Returns:\n            Dictionary mapping interval strings to their duration in seconds\n        \"\"\"\n        ...\n\n    def get_ws_supported_intervals(self) -&gt; list[str]:\n        \"\"\"Get intervals supported by WebSocket API.\n\n        Returns:\n            List of interval strings supported by WebSocket API\n        \"\"\"\n        ...\n</code></pre> <p>               Bases: <code>Protocol</code></p> <p>Protocol for network connection strategies.</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>@runtime_checkable\nclass NetworkStrategy(Protocol):\n    \"\"\"Protocol for network connection strategies.\"\"\"\n\n    async def poll_once(\n        self,\n        start_time: int | None = None,\n        end_time: int | None = None,\n        limit: int | None = None,\n    ) -&gt; list[CandleData]:\n        \"\"\"Fetch candles for a specific time range.\n\n        Args:\n            start_time: Start time in seconds\n            end_time: End time in seconds\n            limit: Maximum number of candles to return\n\n        Returns:\n            List of CandleData objects\n        \"\"\"\n        ...\n\n    async def start(self) -&gt; None:\n        \"\"\"Start the network strategy.\"\"\"\n        ...\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop the network strategy.\"\"\"\n        ...\n</code></pre> <p>               Bases: <code>Protocol</code></p> <p>Protocol for loggers.</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>class Logger(Protocol):\n    \"\"\"Protocol for loggers.\"\"\"\n\n    def debug(self, msg: str, *args, **kwargs) -&gt; None:\n        \"\"\"Log debug message.\"\"\"\n        ...\n\n    def info(self, msg: str, *args, **kwargs) -&gt; None:\n        \"\"\"Log info message.\"\"\"\n        ...\n\n    def warning(self, msg: str, *args, **kwargs) -&gt; None:\n        \"\"\"Log warning message.\"\"\"\n        ...\n\n    def error(self, msg: str, *args, **kwargs) -&gt; None:\n        \"\"\"Log error message.\"\"\"\n        ...\n\n    def exception(self, msg: str, *args, **kwargs) -&gt; None:\n        \"\"\"Log exception message.\"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.CandleDataAdapter.get_rest_params","title":"<code>get_rest_params(trading_pair, interval, start_time=None, end_time=None, limit=None)</code>","text":"<p>Get parameters for REST API request.</p> <p>Parameters:</p> Name Type Description Default <code>trading_pair</code> <code>str</code> <p>Trading pair</p> required <code>interval</code> <code>str</code> <p>Candle interval</p> required <code>start_time</code> <code>int | None</code> <p>Start time in seconds</p> <code>None</code> <code>end_time</code> <code>int | None</code> <p>End time in seconds</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of candles to return</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of parameters for REST API request</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def get_rest_params(\n    self,\n    trading_pair: str,\n    interval: str,\n    start_time: int | None = None,\n    end_time: int | None = None,\n    limit: int | None = None,\n) -&gt; dict:\n    \"\"\"Get parameters for REST API request.\n\n    Args:\n        trading_pair: Trading pair\n        interval: Candle interval\n        start_time: Start time in seconds\n        end_time: End time in seconds\n        limit: Maximum number of candles to return\n\n    Returns:\n        Dictionary of parameters for REST API request\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.CandleDataAdapter.get_rest_url","title":"<code>get_rest_url()</code>","text":"<p>Get REST API URL for candles.</p> <p>Returns:</p> Type Description <code>str</code> <p>REST API URL</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def get_rest_url(self) -&gt; str:\n    \"\"\"Get REST API URL for candles.\n\n    Returns:\n        REST API URL\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.CandleDataAdapter.get_supported_intervals","title":"<code>get_supported_intervals()</code>","text":"<p>Get supported intervals and their durations in seconds.</p> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>Dictionary mapping interval strings to their duration in seconds</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def get_supported_intervals(self) -&gt; dict[str, int]:\n    \"\"\"Get supported intervals and their durations in seconds.\n\n    Returns:\n        Dictionary mapping interval strings to their duration in seconds\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.CandleDataAdapter.get_trading_pair_format","title":"<code>get_trading_pair_format(trading_pair)</code>","text":"<p>Convert standard trading pair format to exchange format.</p> <p>Parameters:</p> Name Type Description Default <code>trading_pair</code> <code>str</code> <p>Trading pair in standard format (e.g., \"BTC-USDT\")</p> required <p>Returns:</p> Type Description <code>str</code> <p>Trading pair in exchange-specific format</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def get_trading_pair_format(self, trading_pair: str) -&gt; str:\n    \"\"\"Convert standard trading pair format to exchange format.\n\n    Args:\n        trading_pair: Trading pair in standard format (e.g., \"BTC-USDT\")\n\n    Returns:\n        Trading pair in exchange-specific format\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.CandleDataAdapter.get_ws_subscription_payload","title":"<code>get_ws_subscription_payload(trading_pair, interval)</code>","text":"<p>Get WebSocket subscription payload.</p> <p>Parameters:</p> Name Type Description Default <code>trading_pair</code> <code>str</code> <p>Trading pair</p> required <code>interval</code> <code>str</code> <p>Candle interval</p> required <p>Returns:</p> Type Description <code>dict</code> <p>WebSocket subscription payload</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def get_ws_subscription_payload(self, trading_pair: str, interval: str) -&gt; dict:\n    \"\"\"Get WebSocket subscription payload.\n\n    Args:\n        trading_pair: Trading pair\n        interval: Candle interval\n\n    Returns:\n        WebSocket subscription payload\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.CandleDataAdapter.get_ws_supported_intervals","title":"<code>get_ws_supported_intervals()</code>","text":"<p>Get intervals supported by WebSocket API.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of interval strings supported by WebSocket API</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def get_ws_supported_intervals(self) -&gt; list[str]:\n    \"\"\"Get intervals supported by WebSocket API.\n\n    Returns:\n        List of interval strings supported by WebSocket API\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.CandleDataAdapter.get_ws_url","title":"<code>get_ws_url()</code>","text":"<p>Get WebSocket URL.</p> <p>Returns:</p> Type Description <code>str</code> <p>WebSocket URL</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def get_ws_url(self) -&gt; str:\n    \"\"\"Get WebSocket URL.\n\n    Returns:\n        WebSocket URL\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.CandleDataAdapter.parse_rest_response","title":"<code>parse_rest_response(data)</code>","text":"<p>Parse REST API response into CandleData objects.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>REST API response</p> required <p>Returns:</p> Type Description <code>list[CandleData]</code> <p>List of CandleData objects</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def parse_rest_response(self, data: Any) -&gt; list[CandleData]:\n    \"\"\"Parse REST API response into CandleData objects.\n\n    Args:\n        data: REST API response\n\n    Returns:\n        List of CandleData objects\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.CandleDataAdapter.parse_ws_message","title":"<code>parse_ws_message(data)</code>","text":"<p>Parse WebSocket message into CandleData objects.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>WebSocket message</p> required <p>Returns:</p> Type Description <code>list[CandleData] | None</code> <p>List of CandleData objects or None if message is not a candle update</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def parse_ws_message(self, data: Any) -&gt; list[CandleData] | None:\n    \"\"\"Parse WebSocket message into CandleData objects.\n\n    Args:\n        data: WebSocket message\n\n    Returns:\n        List of CandleData objects or None if message is not a candle update\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.NetworkStrategy.poll_once","title":"<code>poll_once(start_time=None, end_time=None, limit=None)</code>  <code>async</code>","text":"<p>Fetch candles for a specific time range.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>int | None</code> <p>Start time in seconds</p> <code>None</code> <code>end_time</code> <code>int | None</code> <p>End time in seconds</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of candles to return</p> <code>None</code> <p>Returns:</p> Type Description <code>list[CandleData]</code> <p>List of CandleData objects</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>async def poll_once(\n    self,\n    start_time: int | None = None,\n    end_time: int | None = None,\n    limit: int | None = None,\n) -&gt; list[CandleData]:\n    \"\"\"Fetch candles for a specific time range.\n\n    Args:\n        start_time: Start time in seconds\n        end_time: End time in seconds\n        limit: Maximum number of candles to return\n\n    Returns:\n        List of CandleData objects\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.NetworkStrategy.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start the network strategy.</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"Start the network strategy.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.NetworkStrategy.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop the network strategy.</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the network strategy.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.Logger.debug","title":"<code>debug(msg, *args, **kwargs)</code>","text":"<p>Log debug message.</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def debug(self, msg: str, *args, **kwargs) -&gt; None:\n    \"\"\"Log debug message.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.Logger.error","title":"<code>error(msg, *args, **kwargs)</code>","text":"<p>Log error message.</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def error(self, msg: str, *args, **kwargs) -&gt; None:\n    \"\"\"Log error message.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.Logger.exception","title":"<code>exception(msg, *args, **kwargs)</code>","text":"<p>Log exception message.</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def exception(self, msg: str, *args, **kwargs) -&gt; None:\n    \"\"\"Log exception message.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.Logger.info","title":"<code>info(msg, *args, **kwargs)</code>","text":"<p>Log info message.</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def info(self, msg: str, *args, **kwargs) -&gt; None:\n    \"\"\"Log info message.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/core/#candles_feed.core.protocols.Logger.warning","title":"<code>warning(msg, *args, **kwargs)</code>","text":"<p>Log warning message.</p> Source code in <code>candles_feed/core/protocols.py</code> <pre><code>def warning(self, msg: str, *args, **kwargs) -&gt; None:\n    \"\"\"Log warning message.\"\"\"\n    ...\n</code></pre>"},{"location":"development/coding_standards/","title":"Coding Standards","text":"<p>This guide outlines the coding standards and best practices for the Candles Feed project. Following these standards ensures consistency, readability, and maintainability across the codebase.</p>"},{"location":"development/coding_standards/#python-version","title":"Python Version","text":"<p>The project uses Python 3.12+ features and follows modern Python conventions:</p> <pre><code># Do this - Python 3.12+ style\ndata: dict[str, int] = {\"key\": 42}\nvalues: list[float] = [1.0, 2.0, 3.0]\nresult: int | None = None\n</code></pre>"},{"location":"development/coding_standards/#type-hints","title":"Type Hints","text":""},{"location":"development/coding_standards/#collection-types","title":"Collection Types","text":"<p>Use the built-in collection types for type hints, not those from the <code>typing</code> module:</p> <pre><code># Do this (Python 3.9+)\nfrom collections import deque\n\ndef process_items(items: list[int], cache: dict[str, float], queue: deque[str]) -&gt; None:\n    pass\n\n# Don't do this (Python 3.8 or earlier style)\nfrom typing import Dict, List, Deque\n\ndef process_items(items: List[int], cache: Dict[str, float], queue: Deque[str]) -&gt; None:\n    pass\n</code></pre>"},{"location":"development/coding_standards/#union-types","title":"Union Types","text":"<p>Use the union operator (<code>|</code>) for union types, not <code>Union</code> from the <code>typing</code> module:</p> <pre><code># Do this (Python 3.10+)\ndef get_value(key: str) -&gt; int | float | None:\n    pass\n\n# Don't do this\nfrom typing import Union\ndef get_value(key: str) -&gt; Union[int, float, None]:\n    pass\n</code></pre>"},{"location":"development/coding_standards/#optional-types","title":"Optional Types","text":"<p>Use the union with <code>None</code> for optional types, not <code>Optional</code> from the <code>typing</code> module:</p> <pre><code># Do this (Python 3.10+)\ndef process(value: str | None = None) -&gt; None:\n    pass\n\n# Don't do this\nfrom typing import Optional\ndef process(value: Optional[str] = None) -&gt; None:\n    pass\n</code></pre>"},{"location":"development/coding_standards/#docstrings","title":"Docstrings","text":"<p>All classes, methods, and functions should have docstrings in reStructuredText format:</p> <pre><code>def get_trading_pair_format(self, trading_pair: str) -&gt; str:\n    \"\"\"\n    Format a trading pair according to exchange requirements.\n\n    :param trading_pair: The trading pair in standard format (e.g., \"BTC-USDT\")\n    :return: The exchange-specific trading pair format (e.g., \"BTCUSDT\")\n    :raises ValueError: If the trading pair is invalid\n    :note: Different exchanges may have different formats for trading pairs\n    \"\"\"\n    # Implementation...\n</code></pre>"},{"location":"development/coding_standards/#docstring-structure","title":"Docstring Structure","text":"<ol> <li>Summary Line: A brief one-line description</li> <li>Blank Line: Required after the summary</li> <li>Detailed Description: If needed</li> <li>Parameter Section: List all parameters with descriptions</li> <li>Return Section: Describe the return value</li> <li>Raise Section: List all exceptions that may be raised</li> <li>Note Section: Additional notes if necessary</li> </ol>"},{"location":"development/coding_standards/#method-signatures","title":"Method Signatures","text":"<p>For methods with multiple parameters, use the following alignment:</p> <pre><code>def fetch_historical_data(\n    self,\n    trading_pair: str,\n    interval: str,\n    start_time: int | None = None,\n    end_time: int | None = None,\n    limit: int = 100\n) -&gt; list[CandleData]:\n    \"\"\"Method docstring...\"\"\"\n    # Implementation...\n</code></pre>"},{"location":"development/coding_standards/#return-types","title":"Return Types","text":"<p>Always specify return types, including <code>None</code> for methods that don't return a value:</p> <pre><code>def start_feed(self) -&gt; None:\n    \"\"\"Start the data feed.\"\"\"\n    # Implementation...\n\ndef get_candles(self) -&gt; list[CandleData]:\n    \"\"\"Get current candles data.\"\"\"\n    return list(self._candles)\n</code></pre>"},{"location":"development/coding_standards/#code-structure","title":"Code Structure","text":""},{"location":"development/coding_standards/#class-attributes","title":"Class Attributes","text":"<p>Use <code>ClassVar</code> for class-level attributes:</p> <pre><code>from typing import ClassVar\n\nclass ExchangeAdapter:\n    # Class-level constants\n    SUPPORTED_INTERVALS: ClassVar[dict[str, int]] = {\n        \"1m\": 60,\n        \"5m\": 300,\n        \"1h\": 3600\n    }\n\n    # Instance attributes\n    def __init__(self, api_key: str):\n        self.api_key = api_key\n        self._is_connected = False\n</code></pre>"},{"location":"development/coding_standards/#error-handling","title":"Error Handling","text":"<p>Use proper exception chaining and helpful error messages:</p> <pre><code>try:\n    response = await self._network_client.fetch(url)\n    return self._parse_response(response)\nexcept NetworkError as e:\n    raise ExchangeConnectionError(f\"Failed to connect to {self.exchange_name}\") from e\nexcept InvalidResponseError as e:\n    raise DataParsingError(f\"Invalid response format: {e}\") from e\n</code></pre>"},{"location":"development/coding_standards/#variable-naming","title":"Variable Naming","text":"<p>Follow these naming conventions:</p> <ol> <li>Class Names: <code>CamelCase</code> (e.g., <code>CandleData</code>, <code>BinanceAdapter</code>)</li> <li>Function/Method Names: <code>snake_case</code> (e.g., <code>get_candles</code>, <code>format_trading_pair</code>)</li> <li>Variable Names: <code>snake_case</code> (e.g., <code>candle_data</code>, <code>trading_pair</code>)</li> <li>Constants: <code>UPPER_CASE</code> (e.g., <code>DEFAULT_TIMEOUT</code>, <code>API_VERSION</code>)</li> <li>Private Members: Prefix with underscore (e.g., <code>_candles</code>, <code>_fetch_data</code>)</li> </ol>"},{"location":"development/coding_standards/#additional-best-practices","title":"Additional Best Practices","text":"<ol> <li>Line Length: Maximum 100 characters (soft limit)</li> <li>Import Order: Standard library, third-party, local modules</li> <li>Whitespace: Follow PEP 8 conventions</li> <li>Comments: Use them sparingly to explain \"why\", not \"what\"</li> <li>String Formatting: Use f-strings instead of older methods when possible</li> <li>Type Guards: Use explicit type checking where necessary</li> </ol>"},{"location":"development/coding_standards/#lint-and-type-checking","title":"Lint and Type Checking","text":"<p>All code must pass the following checks before being submitted:</p> <pre><code># Run the linter\npython -m mypy candles_feed\n\n# Run type checking\npython -m mypy candles_feed\n</code></pre>"},{"location":"development/coding_standards/#recommended-ide-setup","title":"Recommended IDE Setup","text":"<p>We recommend using:</p> <ol> <li>Visual Studio Code with:</li> <li>Python extension</li> <li>Pylance (for type checking)</li> <li>Black formatter</li> <li> <p>Ruff (for linting)</p> </li> <li> <p>PyCharm with:</p> </li> <li>Built-in type checking enabled</li> <li>Black plugin</li> <li>Mypy plugin</li> </ol>"},{"location":"development/coding_standards/#code-samples","title":"Code Samples","text":""},{"location":"development/coding_standards/#correct-class-definition","title":"Correct Class Definition","text":"<pre><code>from typing import ClassVar, Protocol\n\nclass Logger(Protocol):\n    def info(self, message: str) -&gt; None: ...\n    def warning(self, message: str) -&gt; None: ...\n    def error(self, message: str) -&gt; None: ...\n\nclass CandleDataProcessor:\n    \"\"\"\n    Process and validate candle data.\n    \"\"\"\n\n    MAX_CANDLES: ClassVar[int] = 1000\n\n    def __init__(self, logger: Logger | None = None):\n        \"\"\"\n        Initialize the processor.\n\n        :param logger: Logger instance for logging events\n        \"\"\"\n        self._logger = logger\n        self._candles: dict[str, list[CandleData]] = {}\n\n    def process_candle(self, candle: CandleData, symbol: str) -&gt; bool:\n        \"\"\"\n        Process a new candle.\n\n        :param candle: The candle data to process\n        :param symbol: The trading pair symbol\n        :return: True if the candle was processed, False otherwise\n        \"\"\"\n        try:\n            self._validate_candle(candle)\n            self._store_candle(candle, symbol)\n            return True\n        except ValueError as e:\n            if self._logger:\n                self._logger.warning(f\"Invalid candle data: {e}\")\n            return False\n</code></pre>"},{"location":"development/coding_standards/#correct-error-handling","title":"Correct Error Handling","text":"<pre><code>async def fetch_data(self, url: str, params: dict[str, str]) -&gt; dict[str, any]:\n    \"\"\"\n    Fetch data from an API endpoint.\n\n    :param url: The URL to fetch from\n    :param params: Query parameters\n    :return: The parsed JSON response\n    :raises ConnectionError: If the connection fails\n    :raises TimeoutError: If the request times out\n    :raises APIError: If the API returns an error\n    \"\"\"\n    try:\n        response = await self._client.get(url, params=params)\n        response.raise_for_status()\n        return response.json()\n    except aiohttp.ClientConnectionError as e:\n        raise ConnectionError(f\"Failed to connect to {url}\") from e\n    except aiohttp.ClientResponseError as e:\n        raise APIError(f\"API error: {e.status} - {e.message}\") from e\n    except asyncio.TimeoutError as e:\n        raise TimeoutError(f\"Request to {url} timed out\") from e\n</code></pre>"},{"location":"examples/binance_spot_example/","title":"Binance Spot Example","text":"<p>This example demonstrates how to use the Candles Feed framework with Binance Spot exchange. It shows the basic setup and usage patterns for fetching and working with candle data.</p>"},{"location":"examples/binance_spot_example/#prerequisites","title":"Prerequisites","text":"<p>Before running this example, make sure you have installed the Candles Feed package:</p> <pre><code>pip install hummingbot-candles-feed\n</code></pre>"},{"location":"examples/binance_spot_example/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom candles_feed.core.candles_feed import CandlesFeed\n\nasync def main():\n    \"\"\"Simple example using Binance Spot.\"\"\"\n    # Create a CandlesFeed instance for Binance Spot\n    feed = CandlesFeed(\n        exchange=\"binance_spot\",\n        trading_pair=\"BTC-USDT\",\n        interval=\"1m\",\n        max_records=100\n    )\n\n    try:\n        # Fetch historical candles\n        print(\"Fetching historical candles...\")\n        candles = await feed.fetch_candles()\n        print(f\"Fetched {len(candles)} candles\")\n\n        # Start real-time updates (using WebSocket by default)\n        print(\"Starting real-time updates...\")\n        await feed.start()\n\n        # Wait for some data to accumulate\n        for i in range(5):\n            print(f\"Waiting... ({i+1}/5)\")\n            await asyncio.sleep(10)\n\n            # Get the current candles\n            candles = feed.get_candles()\n            if candles:\n                latest = candles[-1]\n                print(f\"Latest price: {latest.close} (timestamp: {latest.timestamp})\")\n\n    finally:\n        # Always stop the feed when done\n        print(\"Stopping feed...\")\n        await feed.stop()\n        print(\"Feed stopped\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/binance_spot_example/#using-pandas-dataframe","title":"Using Pandas DataFrame","text":"<p>The Candles Feed framework provides a convenient method to convert candle data to a pandas DataFrame:</p> <pre><code>import asyncio\nimport pandas as pd\nfrom candles_feed.core.candles_feed import CandlesFeed\n\nasync def analyze_btc():\n    \"\"\"Example showing DataFrame conversion and analysis.\"\"\"\n    feed = CandlesFeed(\n        exchange=\"binance_spot\",\n        trading_pair=\"BTC-USDT\",\n        interval=\"1h\",  # 1-hour candles\n        max_records=24  # Last 24 hours\n    )\n\n    try:\n        # Fetch historical data\n        await feed.fetch_candles()\n\n        # Convert to DataFrame\n        df = feed.get_candles_df()\n\n        # Basic analysis\n        print(f\"Data points: {len(df)}\")\n        print(f\"Time range: {df['timestamp'].min()} to {df['timestamp'].max()}\")\n        print(f\"Price range: ${df['low'].min()} - ${df['high'].max()}\")\n        print(f\"Average volume: {df['volume'].mean():.2f}\")\n\n        # Calculate simple moving averages\n        df['SMA_5'] = df['close'].rolling(5).mean()\n        df['SMA_10'] = df['close'].rolling(10).mean()\n\n        # Print the latest values\n        latest = df.iloc[-1]\n        print(f\"Latest close: ${latest['close']}\")\n        print(f\"5-period SMA: ${latest['SMA_5']}\")\n        print(f\"10-period SMA: ${latest['SMA_10']}\")\n\n    finally:\n        await feed.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(analyze_btc())\n</code></pre>"},{"location":"examples/binance_spot_example/#working-with-multiple-trading-pairs","title":"Working with Multiple Trading Pairs","text":"<p>This example shows how to fetch data for multiple trading pairs simultaneously:</p> <pre><code>import asyncio\nfrom candles_feed.core.candles_feed import CandlesFeed\n\nasync def monitor_crypto_markets():\n    \"\"\"Monitor multiple crypto trading pairs.\"\"\"\n    # Define the pairs to monitor\n    pairs = [\n        (\"BTC-USDT\", \"Bitcoin\"),\n        (\"ETH-USDT\", \"Ethereum\"),\n        (\"SOL-USDT\", \"Solana\"),\n        (\"BNB-USDT\", \"Binance Coin\")\n    ]\n\n    # Create feeds for each pair\n    feeds = {}\n    for pair, name in pairs:\n        feeds[pair] = {\n            \"name\": name,\n            \"feed\": CandlesFeed(\n                exchange=\"binance_spot\",\n                trading_pair=pair,\n                interval=\"5m\",\n                max_records=12\n            )\n        }\n\n    try:\n        # Start all feeds\n        for pair_info in feeds.values():\n            await pair_info[\"feed\"].fetch_candles()\n            await pair_info[\"feed\"].start(strategy=\"websocket\")\n\n        # Monitor for a period\n        for i in range(5):\n            print(f\"\\n--- Update {i+1} ---\")\n\n            # Print current prices for all pairs\n            for pair, pair_info in feeds.items():\n                feed = pair_info[\"feed\"]\n                name = pair_info[\"name\"]\n\n                candles = feed.get_candles()\n                if candles:\n                    latest = candles[-1]\n                    price = latest.close\n                    change = ((price / candles[0].close) - 1) * 100\n\n                    print(f\"{name}: ${price:.2f} ({change:+.2f}%)\")\n\n            await asyncio.sleep(60)  # Wait for 1 minute\n\n    finally:\n        # Stop all feeds\n        for pair_info in feeds.values():\n            await pair_info[\"feed\"].stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(monitor_crypto_markets())\n</code></pre>"},{"location":"examples/binance_spot_example/#rest-only-mode","title":"REST-Only Mode","text":"<p>If you prefer to use REST API instead of WebSocket (e.g., for lower resource usage or specific interval requirements):</p> <pre><code>import asyncio\nfrom candles_feed.core.candles_feed import CandlesFeed\n\nasync def main():\n    \"\"\"Example using REST polling only.\"\"\"\n    feed = CandlesFeed(\n        exchange=\"binance_spot\",\n        trading_pair=\"BTC-USDT\",\n        interval=\"15m\",  # 15-minute candles\n        max_records=20\n    )\n\n    try:\n        # Start with REST polling strategy\n        await feed.start(strategy=\"polling\")\n\n        # Monitor for a while\n        for i in range(3):\n            print(f\"Polling iteration {i+1}\")\n            candles = feed.get_candles()\n            if candles:\n                latest = candles[-1]\n                print(f\"Latest candle: OHLC = {latest.open}/{latest.high}/{latest.low}/{latest.close}\")\n\n            # Wait for next poll\n            await asyncio.sleep(30)\n\n    finally:\n        await feed.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/binance_spot_example/#error-handling","title":"Error Handling","text":"<p>It's important to implement proper error handling in your application:</p> <pre><code>import asyncio\nimport logging\nfrom candles_feed.core.candles_feed import CandlesFeed\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def main():\n    \"\"\"Example with error handling.\"\"\"\n    feed = CandlesFeed(\n        exchange=\"binance_spot\",\n        trading_pair=\"BTC-USDT\",\n        interval=\"1m\"\n    )\n\n    try:\n        # Attempt to start the feed\n        try:\n            await feed.start()\n            logger.info(\"Feed started successfully\")\n        except Exception as e:\n            logger.error(f\"Failed to start feed: {str(e)}\")\n            return\n\n        # Monitor and handle potential errors\n        try:\n            for i in range(10):\n                candles = feed.get_candles()\n                if candles:\n                    logger.info(f\"Current price: {candles[-1].close}\")\n                else:\n                    logger.warning(\"No candle data available\")\n\n                await asyncio.sleep(10)\n        except Exception as e:\n            logger.error(f\"Error during monitoring: {str(e)}\")\n\n    finally:\n        # Always attempt to stop the feed\n        try:\n            await feed.stop()\n            logger.info(\"Feed stopped successfully\")\n        except Exception as e:\n            logger.error(f\"Error stopping feed: {str(e)}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/binance_spot_example/#see-also","title":"See Also","text":"<p>For more examples and details, check out:</p> <ul> <li>Simple Usage Guide - For a more basic introduction</li> <li>Mock Server Example - For testing without connecting to real exchanges</li> <li>Adapters Overview - For information on other supported exchanges</li> <li>API Reference - For detailed API documentation</li> </ul>"},{"location":"examples/mock_server_example/","title":"Mock Server Example","text":"<p>This example demonstrates how to use the mock server functionality for testing the Candles Feed framework without connecting to real exchanges. This is particularly useful for development, testing, and CI/CD pipelines.</p>"},{"location":"examples/mock_server_example/#basic-server-setup","title":"Basic Server Setup","text":"<pre><code>import asyncio\nimport logging\nfrom candles_feed.testing_resources.mocked_candle_feed_server import MockedCandlesFeedServer\nfrom candles_feed.testing_resources.mocks.core.exchange_type import ExchangeType\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def main():\n    \"\"\"Example of setting up and using a mock exchange server.\"\"\"\n    # Create a mock server for Binance Spot\n    server = MockedCandlesFeedServer(\n        exchange_type=ExchangeType.BINANCE_SPOT,\n        host=\"127.0.0.1\",\n        port=8080\n    )\n\n    # Configure custom trading pairs\n    custom_pairs = [\n        (\"BTCUSDT\", \"1m\", 50000.0),  # BTC with initial price of $50,000\n        (\"ETHUSDT\", \"1m\", 3000.0),   # ETH with initial price of $3,000\n        (\"SOLUSDT\", \"1m\", 100.0),    # SOL with initial price of $100\n        (\"BTCUSDT\", \"5m\", 50000.0),  # BTC with 5m interval\n        (\"BTCUSDT\", \"1h\", 50000.0),  # BTC with 1h interval\n    ]\n\n    try:\n        # Start the server with our custom pairs\n        await server.start(trading_pairs=custom_pairs)\n        logger.info(f\"Mock exchange server started at {server.url}\")\n\n        # Now you can use the server for testing\n        # ...\n\n        # Let it run for a while to see the logs\n        await asyncio.sleep(5)\n\n    finally:\n        # Always stop the server when done\n        await server.stop()\n        logger.info(\"Server stopped\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/mock_server_example/#using-the-mock-server-with-candlesfeed","title":"Using the Mock Server with CandlesFeed","text":"<p>This example shows how to connect CandlesFeed to the mock server:</p> <pre><code>import asyncio\nimport logging\nfrom candles_feed.core.candles_feed import CandlesFeed\nfrom candles_feed.testing_resources.mocked_candle_feed_server import MockedCandlesFeedServer\nfrom candles_feed.testing_resources.mocks.core.exchange_type import ExchangeType\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def main():\n    \"\"\"Example of using CandlesFeed with a mock server.\"\"\"\n    # Create and start a mock server\n    server = MockedCandlesFeedServer(\n        exchange_type=ExchangeType.BINANCE_SPOT,\n        host=\"127.0.0.1\",\n        port=8080\n    )\n\n    # Start with standard trading pairs\n    await server.start()\n    logger.info(f\"Mock server started at {server.url}\")\n\n    # Create a CandlesFeed instance\n    feed = CandlesFeed(\n        exchange=\"binance_spot\",\n        trading_pair=\"BTC-USDT\",\n        interval=\"1m\",\n        max_records=100\n    )\n\n    # Override the adapter's URL methods to point to our mock server\n    feed._adapter.get_rest_url = lambda: f\"{server.url}/api/v3/klines\"\n    feed._adapter.get_ws_url = lambda: f\"ws://{server.host}:{server.port}/ws\"\n\n    try:\n        # Try both REST and WebSocket strategies\n\n        # 1. First, use REST polling\n        logger.info(\"Testing REST polling strategy...\")\n        await feed.start(strategy=\"polling\")\n\n        # Wait a bit for data to accumulate\n        await asyncio.sleep(2)\n\n        # Check the results\n        candles = feed.get_candles()\n        logger.info(f\"Received {len(candles)} candles via REST\")\n        if candles:\n            logger.info(f\"Latest BTC price: {candles[-1].close}\")\n\n        # Stop the feed\n        await feed.stop()\n\n        # 2. Now, use WebSocket\n        logger.info(\"\\nTesting WebSocket strategy...\")\n        await feed.start(strategy=\"websocket\")\n\n        # Wait for some updates\n        for i in range(5):\n            await asyncio.sleep(1)\n            candles = feed.get_candles()\n            if candles:\n                logger.info(f\"[WS Update {i+1}] BTC price: {candles[-1].close}\")\n\n    finally:\n        # Clean up\n        await feed.stop()\n        await server.stop()\n        logger.info(\"Test completed\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/mock_server_example/#testing-network-conditions","title":"Testing Network Conditions","text":"<p>This example demonstrates how to simulate different network conditions to test error handling:</p> <pre><code>import asyncio\nimport logging\nfrom candles_feed.core.candles_feed import CandlesFeed\nfrom candles_feed.testing_resources.mocked_candle_feed_server import MockedCandlesFeedServer\nfrom candles_feed.testing_resources.mocks.core.exchange_type import ExchangeType\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def main():\n    \"\"\"Example of testing with difficult network conditions.\"\"\"\n    # Create and start a mock server\n    server = MockedCandlesFeedServer(\n        exchange_type=ExchangeType.BINANCE_SPOT,\n        host=\"127.0.0.1\",\n        port=8080\n    )\n\n    await server.start()\n    logger.info(f\"Mock server started at {server.url}\")\n\n    # Create a CandlesFeed instance\n    feed = CandlesFeed(\n        exchange=\"binance_spot\",\n        trading_pair=\"BTC-USDT\",\n        interval=\"1m\",\n        max_records=100\n    )\n\n    # Override the adapter's URL methods\n    feed._adapter.get_rest_url = lambda: f\"{server.url}/api/v3/klines\"\n    feed._adapter.get_ws_url = lambda: f\"ws://{server.host}:{server.port}/ws\"\n\n    try:\n        # First, get data with normal conditions\n        logger.info(\"Fetching data with normal network conditions...\")\n        await feed.fetch_candles()\n        normal_candles = len(feed.get_candles())\n        logger.info(f\"Received {normal_candles} candles\")\n\n        # Now simulate difficult network conditions\n        logger.info(\"\\nSetting difficult network conditions...\")\n        server.set_network_conditions(\n            latency_ms=500,       # 500ms latency\n            packet_loss_rate=0.3, # 30% packet loss\n            error_rate=0.3        # 30% error responses\n        )\n\n        # Try to fetch data under these conditions\n        logger.info(\"Attempting to fetch data with difficult conditions...\")\n        success_count = 0\n        error_count = 0\n\n        for i in range(5):\n            try:\n                logger.info(f\"Attempt {i+1}...\")\n                await feed.fetch_candles()\n                success_count += 1\n                logger.info(\"Success!\")\n            except Exception as e:\n                error_count += 1\n                logger.warning(f\"Failed: {str(e)}\")\n\n            await asyncio.sleep(1)\n\n        logger.info(f\"\\nResults: {success_count} successes, {error_count} failures\")\n\n        # Reset to normal conditions\n        logger.info(\"\\nResetting to normal network conditions...\")\n        server.set_network_conditions(\n            latency_ms=0,\n            packet_loss_rate=0.0,\n            error_rate=0.0\n        )\n\n        # Try one more fetch\n        logger.info(\"Fetching data with normal conditions again...\")\n        await feed.fetch_candles()\n        new_count = len(feed.get_candles())\n        logger.info(f\"Received {new_count} candles\")\n\n    finally:\n        # Clean up\n        await feed.stop()\n        await server.stop()\n        logger.info(\"Test completed\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/mock_server_example/#testing-rate-limiting","title":"Testing Rate Limiting","text":"<p>This example shows how to test rate limiting behavior:</p> <pre><code>import asyncio\nimport logging\nimport time\nfrom candles_feed.testing_resources.mocked_candle_feed_server import MockedCandlesFeedServer\nfrom candles_feed.testing_resources.mocks.core.exchange_type import ExchangeType\nimport aiohttp\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def main():\n    \"\"\"Example of testing rate limiting.\"\"\"\n    # Create and start a mock server\n    server = MockedCandlesFeedServer(\n        exchange_type=ExchangeType.BINANCE_SPOT,\n        host=\"127.0.0.1\",\n        port=8080\n    )\n\n    await server.start()\n    logger.info(f\"Mock server started at {server.url}\")\n\n    # Set custom rate limits\n    server.set_rate_limits(\n        rest_limit=5,        # Only 5 requests\n        rest_period_ms=5000, # Per 5 seconds\n        ws_limit=2,          # 2 messages\n        ws_burst=3           # Burst of 3 allowed\n    )\n\n    try:\n        # Create an HTTP session for testing\n        async with aiohttp.ClientSession() as session:\n            # Make requests in a loop to hit the rate limit\n            logger.info(\"Making rapid requests to test rate limiting...\")\n\n            success_count = 0\n            rate_limited_count = 0\n\n            # Try to make 10 requests quickly\n            for i in range(10):\n                try:\n                    start_time = time.time()\n\n                    # Make a request to the klines endpoint\n                    url = f\"{server.url}/api/v3/klines?symbol=BTCUSDT&amp;interval=1m&amp;limit=10\"\n                    async with session.get(url) as response:\n                        elapsed = time.time() - start_time\n\n                        if response.status == 200:\n                            success_count += 1\n                            logger.info(f\"Request {i+1}: Success ({elapsed:.2f}s)\")\n                        elif response.status == 429:  # Too Many Requests\n                            rate_limited_count += 1\n                            logger.warning(f\"Request {i+1}: Rate limited! ({elapsed:.2f}s)\")\n                            retry_after = response.headers.get('Retry-After', 'unknown')\n                            logger.warning(f\"Retry-After: {retry_after}s\")\n                        else:\n                            logger.error(f\"Request {i+1}: Unexpected status {response.status}\")\n\n                except Exception as e:\n                    logger.error(f\"Request {i+1}: Error - {str(e)}\")\n\n                # Small delay to make the output readable\n                await asyncio.sleep(0.2)\n\n            logger.info(f\"\\nRate limit test results:\")\n            logger.info(f\"Successful requests: {success_count}\")\n            logger.info(f\"Rate limited requests: {rate_limited_count}\")\n\n            # Wait for rate limit to reset\n            logger.info(\"\\nWaiting for rate limit to reset...\")\n            await asyncio.sleep(5)\n\n            # Try one more request\n            logger.info(\"Making one more request after waiting...\")\n            async with session.get(f\"{server.url}/api/v3/klines?symbol=BTCUSDT&amp;interval=1m&amp;limit=10\") as response:\n                if response.status == 200:\n                    logger.info(\"Success! Rate limit has reset.\")\n                else:\n                    logger.warning(f\"Still rate limited: {response.status}\")\n\n    finally:\n        # Clean up\n        await server.stop()\n        logger.info(\"Test completed\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/mock_server_example/#see-also","title":"See Also","text":"<p>For more information about the mock server functionality, refer to:</p> <ul> <li>Mock Server Documentation</li> <li>Exchange Simulation</li> <li>Candle Data Factory</li> <li>Testing Guide</li> </ul>"},{"location":"examples/simple_usage/","title":"Simple Usage Examples","text":"<p>This document provides examples of common usage patterns for the Candles Feed package.</p>"},{"location":"examples/simple_usage/#basic-rest-api-example","title":"Basic REST API Example","text":"<p>The following example demonstrates how to fetch historical candle data using the REST API:</p> <pre><code>import asyncio\nimport time\nfrom candles_feed.core.candles_feed import CandlesFeed\n\nasync def main():\n    # Create a feed for Binance BTC-USDT with 1-hour candles\n    feed = CandlesFeed(\n        exchange=\"binance_spot\",\n        trading_pair=\"BTC-USDT\",\n        interval=\"1h\",\n        max_records=24  # Keep last 24 hours\n    )\n\n    # Calculate time range for the last 24 hours\n    end_time = int(time.time())\n    start_time = end_time - (24 * 60 * 60)  # 24 hours ago\n\n    # Fetch historical candles\n    candles = await feed.fetch_candles(start_time=start_time, end_time=end_time)\n    print(f\"Fetched {len(candles)} candles\")\n\n    # Print details of the first and last candle\n    if candles:\n        first_candle = candles[0]\n        last_candle = candles[-1]\n\n        print(\"\\nFirst candle:\")\n        print(f\"Timestamp: {first_candle.timestamp}\")\n        print(f\"Open: {first_candle.open}\")\n        print(f\"High: {first_candle.high}\")\n        print(f\"Low: {first_candle.low}\")\n        print(f\"Close: {first_candle.close}\")\n        print(f\"Volume: {first_candle.volume}\")\n\n        print(\"\\nLast candle:\")\n        print(f\"Timestamp: {last_candle.timestamp}\")\n        print(f\"Open: {last_candle.open}\")\n        print(f\"High: {last_candle.high}\")\n        print(f\"Low: {last_candle.low}\")\n        print(f\"Close: {last_candle.close}\")\n        print(f\"Volume: {last_candle.volume}\")\n\n    # Get data as pandas DataFrame\n    df = feed.get_candles_df()\n    print(\"\\nDataFrame summary:\")\n    print(df.describe())\n\n    # Clean up resources\n    await feed.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/simple_usage/#websocket-streaming-example","title":"WebSocket Streaming Example","text":"<p>This example shows how to stream real-time candle data using WebSockets:</p> <pre><code>import asyncio\nimport logging\nfrom candles_feed.core.candles_feed import CandlesFeed\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def main():\n    # Create a feed with 1-minute candles\n    feed = CandlesFeed(\n        exchange=\"binance_spot\",\n        trading_pair=\"BTC-USDT\",\n        interval=\"1m\",\n        max_records=60  # Keep last 60 minutes\n    )\n\n    # Start WebSocket streaming\n    await feed.start(strategy=\"websocket\")\n    logger.info(\"WebSocket feed started\")\n\n    # Monitor for updates\n    try:\n        start_time = asyncio.get_event_loop().time()\n        while asyncio.get_event_loop().time() - start_time &lt; 60:  # Run for 1 minute\n            candles = feed.get_candles()\n            if candles:\n                latest = candles[-1]\n                logger.info(\n                    f\"Latest candle: timestamp={latest.timestamp}, \"\n                    f\"open={latest.open}, high={latest.high}, \"\n                    f\"low={latest.low}, close={latest.close}, \"\n                    f\"volume={latest.volume}\"\n                )\n            await asyncio.sleep(5)  # Check every 5 seconds\n    finally:\n        # Always clean up resources\n        await feed.stop()\n        logger.info(\"WebSocket feed stopped\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/simple_usage/#multi-exchange-example","title":"Multi-Exchange Example","text":"<p>This example demonstrates how to work with multiple exchanges simultaneously:</p> <pre><code>import asyncio\nimport logging\nfrom candles_feed.core.candles_feed import CandlesFeed\nfrom candles_feed.core.exchange_registry import ExchangeRegistry\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def main():\n    # List available exchange adapters\n    ExchangeRegistry.discover_adapters()\n    exchanges = ExchangeRegistry.list_available_adapters()\n    logger.info(f\"Available exchanges: {exchanges}\")\n\n    # Create feeds for different exchanges with the same trading pair\n    feeds = []\n    exchange_names = [\"binance_spot\", \"kucoin_spot\", \"coinbase_advanced_trade\"]\n\n    for exchange in exchange_names:\n        if exchange in exchanges:\n            try:\n                feed = CandlesFeed(\n                    exchange=exchange,\n                    trading_pair=\"BTC-USDT\",  # Note: May be BTC-USD on some exchanges\n                    interval=\"1m\",\n                    max_records=10\n                )\n                feeds.append((exchange, feed))\n                logger.info(f\"Created feed for {exchange}\")\n            except Exception as e:\n                logger.error(f\"Error creating feed for {exchange}: {e}\")\n\n    # Start all feeds\n    start_tasks = []\n    for exchange, feed in feeds:\n        start_tasks.append(feed.start())\n\n    await asyncio.gather(*start_tasks)\n    logger.info(\"All feeds started\")\n\n    # Wait for data to arrive\n    await asyncio.sleep(10)\n\n    # Compare prices across exchanges\n    logger.info(\"\\nCurrent BTC prices across exchanges:\")\n    for exchange, feed in feeds:\n        candles = feed.get_candles()\n        if candles:\n            latest = candles[-1]\n            logger.info(f\"{exchange}: close={latest.close}, volume={latest.volume}\")\n        else:\n            logger.warning(f\"{exchange}: No data received\")\n\n    # Stop all feeds\n    stop_tasks = []\n    for _, feed in feeds:\n        stop_tasks.append(feed.stop())\n\n    await asyncio.gather(*stop_tasks)\n    logger.info(\"All feeds stopped\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/simple_usage/#data-analysis-example","title":"Data Analysis Example","text":"<p>This example shows how to perform basic analysis on candle data:</p> <pre><code>import asyncio\nimport pandas as pd\nimport numpy as np\nfrom candles_feed.core.candles_feed import CandlesFeed\n\nasync def main():\n    # Create a feed with hourly candles for the last week\n    feed = CandlesFeed(\n        exchange=\"binance_spot\",\n        trading_pair=\"BTC-USDT\",\n        interval=\"1h\",\n        max_records=168  # 24 hours * 7 days\n    )\n\n    # Fetch historical data\n    await feed.fetch_candles()\n\n    # Get data as DataFrame\n    df = feed.get_candles_df()\n    if df.empty:\n        print(\"No data received\")\n        await feed.stop()\n        return\n\n    # Convert timestamp to datetime for better readability\n    df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')\n\n    # Calculate basic technical indicators\n    # 1. Simple Moving Averages\n    df['sma_20'] = df['close'].rolling(window=20).mean()\n    df['sma_50'] = df['close'].rolling(window=50).mean()\n\n    # 2. Exponential Moving Average\n    df['ema_20'] = df['close'].ewm(span=20, adjust=False).mean()\n\n    # 3. Bollinger Bands\n    window = 20\n    df['middle_band'] = df['close'].rolling(window=window).mean()\n    df['std'] = df['close'].rolling(window=window).std()\n    df['upper_band'] = df['middle_band'] + 2 * df['std']\n    df['lower_band'] = df['middle_band'] - 2 * df['std']\n\n    # 4. Relative Strength Index (RSI)\n    delta = df['close'].diff()\n    gain = delta.where(delta &gt; 0, 0)\n    loss = -delta.where(delta &lt; 0, 0)\n\n    avg_gain = gain.rolling(window=14).mean()\n    avg_loss = loss.rolling(window=14).mean()\n\n    rs = avg_gain / avg_loss\n    df['rsi'] = 100 - (100 / (1 + rs))\n\n    # 5. MACD\n    df['ema_12'] = df['close'].ewm(span=12, adjust=False).mean()\n    df['ema_26'] = df['close'].ewm(span=26, adjust=False).mean()\n    df['macd'] = df['ema_12'] - df['ema_26']\n    df['signal'] = df['macd'].ewm(span=9, adjust=False).mean()\n    df['macd_histogram'] = df['macd'] - df['signal']\n\n    # Display analysis results\n    print(\"\\nAnalysis of BTC-USDT price data:\")\n    print(f\"Period: {df['datetime'].iloc[0]} to {df['datetime'].iloc[-1]}\")\n    print(f\"Number of candles: {len(df)}\")\n    print(f\"Price range: {df['low'].min()} - {df['high'].max()}\")\n    print(f\"Average volume: {df['volume'].mean():.2f}\")\n\n    print(\"\\nLatest indicators:\")\n    latest = df.iloc[-1]\n    print(f\"Price: {latest['close']}\")\n    print(f\"SMA (20): {latest['sma_20']}\")\n    print(f\"EMA (20): {latest['ema_20']}\")\n    print(f\"Bollinger Bands: {latest['lower_band']:.2f} - {latest['middle_band']:.2f} - {latest['upper_band']:.2f}\")\n    print(f\"RSI: {latest['rsi']:.2f}\")\n    print(f\"MACD: {latest['macd']:.2f}, Signal: {latest['signal']:.2f}, Histogram: {latest['macd_histogram']:.2f}\")\n\n    # Clean up\n    await feed.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/simple_usage/#error-handling-example","title":"Error Handling Example","text":"<p>This example demonstrates robust error handling:</p> <pre><code>import asyncio\nimport logging\nimport time\nfrom candles_feed.core.candles_feed import CandlesFeed\nfrom candles_feed.core.exchange_registry import ExchangeRegistry\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def fetch_with_retry(exchange, trading_pair, interval, retries=3):\n    \"\"\"Fetch candle data with retry logic.\"\"\"\n    feed = None\n    try:\n        feed = CandlesFeed(\n            exchange=exchange,\n            trading_pair=trading_pair,\n            interval=interval,\n            max_records=100\n        )\n\n        # Try to fetch data with retries\n        attempt = 0\n        success = False\n\n        while attempt &lt; retries and not success:\n            attempt += 1\n            try:\n                logger.info(f\"Attempt {attempt} to fetch candles for {trading_pair} on {exchange}\")\n                candles = await feed.fetch_candles()\n\n                if candles and len(candles) &gt; 0:\n                    logger.info(f\"Successfully fetched {len(candles)} candles\")\n                    success = True\n                    return candles\n                else:\n                    logger.warning(f\"No candles received on attempt {attempt}\")\n                    await asyncio.sleep(2 ** attempt)  # Exponential backoff\n            except Exception as e:\n                logger.error(f\"Error fetching candles (attempt {attempt}): {e}\")\n                if attempt &lt; retries:\n                    await asyncio.sleep(2 ** attempt)  # Exponential backoff\n\n        if not success:\n            logger.error(f\"Failed to fetch candles after {retries} attempts\")\n            return []\n\n    except Exception as e:\n        logger.error(f\"Error creating feed: {e}\")\n        return []\n    finally:\n        if feed:\n            await feed.stop()\n\nasync def main():\n    # Get available exchanges\n    try:\n        ExchangeRegistry.discover_adapters()\n        exchanges = ExchangeRegistry.list_available_adapters()\n        logger.info(f\"Available exchanges: {exchanges}\")\n    except Exception as e:\n        logger.error(f\"Error discovering adapters: {e}\")\n        return\n\n    # Fetch data from multiple exchanges with error handling\n    results = {}\n    tasks = []\n\n    for exchange in [\"binance_spot\", \"kraken_spot\", \"non_existent_exchange\"]:\n        if exchange in exchanges or exchange == \"non_existent_exchange\":\n            task = asyncio.create_task(\n                fetch_with_retry(\n                    exchange=exchange,\n                    trading_pair=\"BTC-USDT\",\n                    interval=\"1h\"\n                )\n            )\n            tasks.append((exchange, task))\n\n    # Wait for all tasks to complete\n    for exchange, task in tasks:\n        try:\n            candles = await task\n            results[exchange] = candles\n        except Exception as e:\n            logger.error(f\"Error in task for {exchange}: {e}\")\n            results[exchange] = []\n\n    # Display results\n    for exchange, candles in results.items():\n        if candles:\n            logger.info(f\"{exchange}: Successfully fetched {len(candles)} candles\")\n        else:\n            logger.warning(f\"{exchange}: No candles fetched\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/simple_usage/#real-time-trading-signal-example","title":"Real-time Trading Signal Example","text":"<p>This example demonstrates how to generate simple trading signals from real-time data:</p> <pre><code>import asyncio\nimport logging\nfrom candles_feed.core.candles_feed import CandlesFeed\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass SimpleStrategy:\n    \"\"\"A simple trading strategy using moving averages.\"\"\"\n\n    def __init__(self, short_window=5, long_window=20):\n        self.short_window = short_window\n        self.long_window = long_window\n        self.positions = []  # Track positions: 1 for long, -1 for short, 0 for neutral\n\n    def calculate_signals(self, df):\n        \"\"\"Calculate trading signals based on moving average crossover.\"\"\"\n        if len(df) &lt; self.long_window:\n            return \"INSUFFICIENT_DATA\"\n\n        # Calculate moving averages\n        df['short_ma'] = df['close'].rolling(window=self.short_window).mean()\n        df['long_ma'] = df['close'].rolling(window=self.long_window).mean()\n\n        # Current position\n        current_position = 0\n        if len(self.positions) &gt; 0:\n            current_position = self.positions[-1]\n\n        # Get the last two rows to check for a crossover\n        if len(df) &gt;= 2:\n            prev_row = df.iloc[-2]\n            curr_row = df.iloc[-1]\n\n            # Check for crossing conditions\n            prev_crossing = prev_row['short_ma'] &gt; prev_row['long_ma']\n            curr_crossing = curr_row['short_ma'] &gt; curr_row['long_ma']\n\n            # Generate signals\n            if not prev_crossing and curr_crossing:  # Bullish crossover\n                if current_position &lt;= 0:\n                    self.positions.append(1)\n                    return \"BUY\"\n            elif prev_crossing and not curr_crossing:  # Bearish crossover\n                if current_position &gt;= 0:\n                    self.positions.append(-1)\n                    return \"SELL\"\n\n        self.positions.append(current_position)\n        return \"HOLD\"\n\nasync def main():\n    # Create a feed for real-time data\n    feed = CandlesFeed(\n        exchange=\"binance_spot\",\n        trading_pair=\"BTC-USDT\",\n        interval=\"1m\",\n        max_records=30  # Keep enough for our strategy\n    )\n\n    # Initialize our strategy\n    strategy = SimpleStrategy(short_window=5, long_window=20)\n\n    # Start the feed\n    await feed.start(strategy=\"websocket\")\n    logger.info(\"Started real-time feed\")\n\n    try:\n        # Run for a limited time (5 minutes)\n        start_time = asyncio.get_event_loop().time()\n\n        while asyncio.get_event_loop().time() - start_time &lt; 300:\n            # Get latest data\n            df = feed.get_candles_df()\n\n            if not df.empty and len(df) &gt;= strategy.long_window:\n                # Calculate signals\n                signal = strategy.calculate_signals(df)\n\n                # Log signal and current price\n                latest_price = df.iloc[-1]['close']\n                logger.info(f\"Signal: {signal}, Price: {latest_price}\")\n\n                if signal == \"BUY\":\n                    logger.info(f\"BUY SIGNAL at {latest_price}\")\n                elif signal == \"SELL\":\n                    logger.info(f\"SELL SIGNAL at {latest_price}\")\n\n            # Wait for next update\n            await asyncio.sleep(10)\n\n    finally:\n        # Clean up\n        await feed.stop()\n        logger.info(\"Stopped feed\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>These examples demonstrate the core functionality of the Candles Feed package. You can adapt and extend them based on your specific requirements.</p>"},{"location":"getting_started/architecture/","title":"Architecture Overview","text":"<p>This page provides a detailed overview of the Candles Feed framework architecture, explaining the design principles, key components, and how they interact.</p>"},{"location":"getting_started/architecture/#design-principles","title":"Design Principles","text":"<p>The Candles Feed framework was designed with the following principles in mind:</p> <ol> <li>Modularity: Components are designed to be modular and interchangeable, allowing for easy extension and customization.</li> <li>Separation of Concerns: Clear separation between different responsibilities (data retrieval, processing, storage).</li> <li>Extensibility: New exchange adapters can be added without modifying the core framework.</li> <li>Resilience: The system is designed to handle network issues, exchange errors, and other potential failures.</li> <li>Performance: Optimized for efficient data processing and memory usage.</li> </ol>"},{"location":"getting_started/architecture/#core-components","title":"Core Components","text":"<pre><code>graph TD\n    Client[Client Application] --&gt; CandlesFeed\n\n    subgraph \"Core Framework\"\n        CandlesFeed --&gt; |manages| DataProcessor\n        CandlesFeed --&gt; |uses| NetworkStrategy\n        CandlesFeed --&gt; |interacts with| ExchangeRegistry\n\n        NetworkStrategy --&gt; |implements| WebSocketStrategy\n        NetworkStrategy --&gt; |implements| RESTPollingStrategy\n\n        WebSocketStrategy --&gt; |uses| NetworkClient\n        RESTPollingStrategy --&gt; |uses| NetworkClient\n\n        ExchangeRegistry --&gt; |maintains| AdapterRegistry\n    end\n\n    subgraph \"Exchange Adapters\"\n        AdapterRegistry --&gt; |contains| BaseAdapter\n        BaseAdapter --&gt; |implements| BinanceAdapter\n        BaseAdapter --&gt; |implements| BybitAdapter\n        BaseAdapter --&gt; |implements| CoinbaseAdapter\n        BaseAdapter --&gt; |implements| KrakenAdapter\n        BaseAdapter --&gt; |implements| OtherAdapters[Other Exchange Adapters...]\n    end\n\n    subgraph \"Data Model\"\n        DataProcessor --&gt; |creates/manages| CandleData\n        WebSocketStrategy --&gt; |produces| CandleData\n        RESTPollingStrategy --&gt; |produces| CandleData\n    end\n\n    style OtherAdapters fill:#f96</code></pre>"},{"location":"getting_started/architecture/#component-responsibilities","title":"Component Responsibilities","text":""},{"location":"getting_started/architecture/#candlesfeed","title":"CandlesFeed","text":"<p>The central coordinator that manages the entire data collection process:</p> <ul> <li>Initializes and configures the required components</li> <li>Selects the appropriate network strategy (WebSocket or REST polling)</li> <li>Maintains the candle data collection</li> <li>Provides methods to start/stop data collection and access the data</li> </ul>"},{"location":"getting_started/architecture/#networkstrategy","title":"NetworkStrategy","text":"<p>Abstract strategy for retrieving candle data from exchanges:</p> <ul> <li>WebSocketStrategy: Connects to exchange WebSocket APIs for real-time data</li> <li>RESTPollingStrategy: Periodically polls exchange REST APIs for data</li> </ul>"},{"location":"getting_started/architecture/#exchangeregistry","title":"ExchangeRegistry","text":"<p>Manages exchange adapter registration and instantiation:</p> <ul> <li>Discovers available adapters at runtime</li> <li>Provides adapter instances on demand</li> <li>Allows querying available exchanges</li> </ul>"},{"location":"getting_started/architecture/#adapters","title":"Adapters","text":"<p>Exchange-specific implementations that handle the details of:</p> <ul> <li>Formatting trading pairs for the specific exchange</li> <li>Constructing API requests in the proper format</li> <li>Parsing exchange-specific responses</li> <li>Handling exchange-specific error conditions</li> </ul>"},{"location":"getting_started/architecture/#data-processor","title":"Data Processor","text":"<p>Handles the processing and storage of candle data:</p> <ul> <li>Validates incoming data</li> <li>Handles duplicate detection and conflict resolution</li> <li>Maintains data consistency</li> </ul>"},{"location":"getting_started/architecture/#candledata","title":"CandleData","text":"<p>Immutable data model representing a single OHLCV candle:</p> <ul> <li>Represents standardized candle data across all exchanges</li> <li>Contains validation logic to ensure data consistency</li> </ul>"},{"location":"getting_started/architecture/#data-flow","title":"Data Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant CandlesFeed\n    participant Strategy as NetworkStrategy\n    participant Adapter\n    participant Exchange\n\n    Client-&gt;&gt;CandlesFeed: create(exchange, pair, interval)\n    CandlesFeed-&gt;&gt;CandlesFeed: get adapter from registry\n\n    Client-&gt;&gt;CandlesFeed: start()\n    CandlesFeed-&gt;&gt;CandlesFeed: select appropriate strategy\n\n    alt WebSocket Strategy\n        CandlesFeed-&gt;&gt;Strategy: start WebSocket connection\n        Strategy-&gt;&gt;Adapter: get websocket URL and payload\n        Strategy-&gt;&gt;Exchange: connect &amp; subscribe\n\n        loop While running\n            Exchange-&gt;&gt;Strategy: send updates\n            Strategy-&gt;&gt;Adapter: parse message\n            Strategy-&gt;&gt;CandlesFeed: update candle data\n        end\n    else REST Polling Strategy\n        CandlesFeed-&gt;&gt;Strategy: start polling\n\n        loop At interval\n            Strategy-&gt;&gt;Adapter: get REST URL and params\n            Strategy-&gt;&gt;Exchange: HTTP request\n            Exchange-&gt;&gt;Strategy: response data\n            Strategy-&gt;&gt;Adapter: parse response\n            Strategy-&gt;&gt;CandlesFeed: update candle data\n        end\n    end\n\n    Client-&gt;&gt;CandlesFeed: get_candles()\n    CandlesFeed-&gt;&gt;Client: return candle data\n\n    Client-&gt;&gt;CandlesFeed: stop()\n    CandlesFeed-&gt;&gt;Strategy: stop\n    Strategy-&gt;&gt;Exchange: disconnect (if WebSocket)</code></pre>"},{"location":"getting_started/architecture/#implementation-details","title":"Implementation Details","text":""},{"location":"getting_started/architecture/#adapter-registration","title":"Adapter Registration","text":"<p>Adapters are registered using a decorator pattern:</p> <pre><code>@ExchangeRegistry.register(\"binance_spot\")\nclass BinanceSpotAdapter(BinanceBaseAdapter):\n    # Implementation details...\n</code></pre>"},{"location":"getting_started/architecture/#strategy-selection","title":"Strategy Selection","text":"<p>CandlesFeed automatically selects the appropriate strategy based on:</p> <ol> <li>The specified strategy parameter (\"auto\", \"websocket\", or \"polling\")</li> <li>The exchange adapter's capabilities (some exchanges don't support WebSocket)</li> <li>The requested interval (some intervals are only available via REST)</li> </ol>"},{"location":"getting_started/architecture/#error-handling","title":"Error Handling","text":"<p>The framework implements robust error handling:</p> <ul> <li>Network transient errors are retried with exponential backoff</li> <li>WebSocket disconnections trigger automatic reconnection</li> <li>Invalid data is logged and filtered out</li> </ul>"},{"location":"getting_started/architecture/#extending-the-framework","title":"Extending the Framework","text":"<p>The modular design makes it easy to extend the framework:</p> <ol> <li>Adding a new exchange: Create a new adapter class implementing the BaseAdapter interface</li> <li>Custom network strategies: Implement a custom NetworkStrategy for specialized behavior</li> <li>Data processors: Extend or replace the default DataProcessor for custom data handling</li> </ol> <p>For more information on extending the framework, see the Adapters section.</p>"},{"location":"getting_started/installation/","title":"Installation","text":"<p>This guide will walk you through the process of installing the Candles Feed framework and setting up your environment.</p>"},{"location":"getting_started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing the framework, ensure you have:</p> <ol> <li>Python 3.8 or later</li> <li>pip (Python package installer)</li> <li>Virtual environment tool (optional but recommended)</li> </ol>"},{"location":"getting_started/installation/#installation-options","title":"Installation Options","text":""},{"location":"getting_started/installation/#option-1-install-from-pypi-recommended","title":"Option 1: Install from PyPI (Recommended)","text":"<p>The easiest way to install the Candles Feed framework is from PyPI:</p> <pre><code>pip install hummingbot-candles-feed\n</code></pre>"},{"location":"getting_started/installation/#option-2-install-from-source","title":"Option 2: Install from Source","text":"<p>To install the latest development version, you can clone the repository and install it directly:</p> <pre><code># Clone the repository\ngit clone https://github.com/hummingbot/hummingbot.git\n\n# Navigate to the project directory\ncd hummingbot/sub-packages/candles-feed\n\n# Install the package in development mode\npip install -e .\n</code></pre>"},{"location":"getting_started/installation/#option-3-using-a-virtual-environment-recommended","title":"Option 3: Using a Virtual Environment (Recommended)","text":"<p>It's recommended to install the framework in a virtual environment to avoid conflicts with other packages:</p> <pre><code># Create a virtual environment\npython -m venv venv\n\n# Activate the virtual environment\n# On Windows:\nvenv\\Scripts\\activate\n# On macOS/Linux:\nsource venv/bin/activate\n\n# Install the package\npip install hummingbot-candles-feed\n</code></pre>"},{"location":"getting_started/installation/#dependencies","title":"Dependencies","text":"<p>The framework has the following core dependencies:</p> <ul> <li><code>numpy</code>: For numerical operations</li> <li><code>pandas</code>: For data manipulation and analysis</li> <li><code>aiohttp</code>: For asynchronous HTTP requests</li> <li><code>websockets</code>: For WebSocket communication</li> <li><code>pydantic</code>: For data validation and settings management</li> </ul> <p>These dependencies will be automatically installed when you install the framework.</p>"},{"location":"getting_started/installation/#verify-installation","title":"Verify Installation","text":"<p>To verify that the installation was successful, run the following in a Python interpreter:</p> <pre><code>&gt;&gt;&gt; from candles_feed import CandlesFeed\n&gt;&gt;&gt; from candles_feed.core.exchange_registry import ExchangeRegistry\n&gt;&gt;&gt; ExchangeRegistry.discover_adapters()\n&gt;&gt;&gt; print(ExchangeRegistry.list_available_adapters())\n</code></pre> <p>This should output a list of available exchange adapters.</p>"},{"location":"getting_started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>For development, testing, and documentation, you may want to install additional packages:</p> <pre><code># Development dependencies\npip install -e \".[dev]\"\n\n# Documentation dependencies\npip install -e \".[doc]\"\n</code></pre>"},{"location":"getting_started/installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues during installation, try the following:</p>"},{"location":"getting_started/installation/#common-issues","title":"Common Issues","text":"<ol> <li>Package not found:    <pre><code>ERROR: Could not find a version that satisfies the requirement hummingbot-candles-feed\n</code></pre></li> </ol> <p>Solution: The package might not be available on PyPI yet. Try installing from source.</p> <ol> <li>Dependency conflicts:    <pre><code>ERROR: Cannot install hummingbot-candles-feed due to package conflicts\n</code></pre></li> </ol> <p>Solution: Use a virtual environment to avoid conflicts with existing packages.</p> <ol> <li>Permission errors:    <pre><code>ERROR: Could not install packages due to an EnvironmentError: [Errno 13] Permission denied\n</code></pre></li> </ol> <p>Solution: Use <code>pip install --user</code> or consider using a virtual environment.</p>"},{"location":"getting_started/installation/#getting-help","title":"Getting Help","text":"<p>If you continue to experience issues, you can:</p> <ol> <li>Check the GitHub Issues page</li> <li>Open a new issue with details about your setup and the error you're encountering</li> <li>Join the community discussion on Discord or other channels</li> </ol>"},{"location":"getting_started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have installed the Candles Feed framework, you can:</p> <ol> <li>Follow the Quick Start guide to begin using the framework</li> <li>Explore the API Reference for detailed documentation</li> <li>Learn about the architecture and core components</li> </ol>"},{"location":"getting_started/quick_start/","title":"Quick Start Guide","text":"<p>This guide will help you get started with the Candles Feed framework quickly. You'll learn how to:</p> <ol> <li>Create a candles feed</li> <li>Fetch real-time candle data</li> <li>Access historical candles</li> <li>Work with different exchanges</li> </ol>"},{"location":"getting_started/quick_start/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example of how to use the Candles Feed framework:</p> <pre><code>import asyncio\nimport pandas as pd\nfrom candles_feed import CandlesFeed\nfrom candles_feed.core.exchange_registry import ExchangeRegistry\n\nasync def main():\n    # Discover available adapters\n    ExchangeRegistry.discover_adapters()\n\n    # Create a candles feed for Binance BTC-USDT pair with 1-minute candles\n    adapter = ExchangeRegistry.get_adapter(\"binance_spot\")\n    candles_feed = CandlesFeed(\n        adapter=adapter,\n        trading_pair=\"BTC-USDT\",\n        interval=\"1m\",\n        max_records=100\n    )\n\n    # Start the feed\n    await candles_feed.start()\n\n    # Wait for the feed to be ready\n    print(\"Waiting for candles data...\")\n    while not candles_feed.ready:\n        await asyncio.sleep(1)\n\n    # Get the candles as a pandas DataFrame\n    df = candles_feed.get_candles_df()\n\n    # Display the data\n    print(\"\\nCandle Data:\")\n    print(df.tail())\n\n    # Keep receiving real-time updates for a while\n    print(\"\\nReceiving real-time updates for 30 seconds...\")\n    await asyncio.sleep(30)\n\n    # Get the updated candles\n    updated_df = candles_feed.get_candles_df()\n    print(\"\\nUpdated Candle Data:\")\n    print(updated_df.tail())\n\n    # Stop the feed\n    await candles_feed.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting_started/quick_start/#selecting-an-exchange","title":"Selecting an Exchange","text":"<p>The framework supports multiple exchanges. To see available exchanges:</p> <pre><code>from candles_feed.core.exchange_registry import ExchangeRegistry\n\n# Discover available adapters\nExchangeRegistry.discover_adapters()\n\n# List all available exchanges\navailable_exchanges = ExchangeRegistry.list_available_adapters()\nprint(f\"Available exchanges: {available_exchanges}\")\n</code></pre> <p>To create a feed for a specific exchange, get the appropriate adapter:</p> <pre><code># For Binance\nadapter = ExchangeRegistry.get_adapter(\"binance_spot\")\n\n# For Coinbase Advanced Trade\nadapter = ExchangeRegistry.get_adapter(\"coinbase_advanced_trade\")\n\n# For Kraken\nadapter = ExchangeRegistry.get_adapter(\"kraken_spot\")\n\n# For KuCoin\nadapter = ExchangeRegistry.get_adapter(\"kucoin_spot\")\n\n# For OKX\nadapter = ExchangeRegistry.get_adapter(\"okx_spot\")\n\n# For Bybit\nadapter = ExchangeRegistry.get_adapter(\"bybit_spot\")\n</code></pre>"},{"location":"getting_started/quick_start/#supported-intervals","title":"Supported Intervals","text":"<p>Different exchanges support different candle intervals. To check supported intervals:</p> <pre><code>adapter = ExchangeRegistry.get_adapter(\"binance_spot\")\nintervals = adapter.get_supported_intervals()\nprint(f\"Supported intervals: {list(intervals.keys())}\")\n</code></pre> <p>Common intervals include: - <code>\"1m\"</code>: 1 minute - <code>\"5m\"</code>: 5 minutes - <code>\"15m\"</code>: 15 minutes - <code>\"1h\"</code>: 1 hour - <code>\"4h\"</code>: 4 hours - <code>\"1d\"</code>: 1 day</p>"},{"location":"getting_started/quick_start/#fetching-historical-data","title":"Fetching Historical Data","text":"<p>To fetch historical candle data for a specific time range:</p> <pre><code>import time\nfrom datetime import datetime, timedelta\n\n# Get timestamps for last 24 hours\nend_time = int(time.time())\nstart_time = end_time - (24 * 60 * 60)  # 24 hours ago\n\n# Fetch historical data\nhistorical_df = await candles_feed.fetch_historical_candles(\n    start_time=start_time,\n    end_time=end_time\n)\n\nprint(f\"Historical data: {len(historical_df)} candles\")\nprint(historical_df.head())\n</code></pre>"},{"location":"getting_started/quick_start/#working-with-multiple-feeds","title":"Working with Multiple Feeds","text":"<p>You can create multiple feeds for different trading pairs or exchanges:</p> <pre><code>async def main():\n    # Discover available adapters\n    ExchangeRegistry.discover_adapters()\n\n    # Create feeds for different trading pairs\n    btc_feed = CandlesFeed(\n        adapter=ExchangeRegistry.get_adapter(\"binance_spot\"),\n        trading_pair=\"BTC-USDT\",\n        interval=\"1m\"\n    )\n\n    eth_feed = CandlesFeed(\n        adapter=ExchangeRegistry.get_adapter(\"binance_spot\"),\n        trading_pair=\"ETH-USDT\",\n        interval=\"1m\"\n    )\n\n    # Start both feeds\n    await asyncio.gather(\n        btc_feed.start(),\n        eth_feed.start()\n    )\n\n    # Wait for data\n    while not (btc_feed.ready and eth_feed.ready):\n        await asyncio.sleep(1)\n\n    # Compare data\n    btc_df = btc_feed.get_candles_df()\n    eth_df = eth_feed.get_candles_df()\n\n    print(\"BTC-USDT latest price:\", btc_df.iloc[-1][\"close\"])\n    print(\"ETH-USDT latest price:\", eth_df.iloc[-1][\"close\"])\n\n    # Stop feeds\n    await asyncio.gather(\n        btc_feed.stop(),\n        eth_feed.stop()\n    )\n</code></pre>"},{"location":"getting_started/quick_start/#data-analysis-example","title":"Data Analysis Example","text":"<p>Here's how to perform basic analysis on the candle data:</p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\n\nasync def analyze_data():\n    # Create and start a feed\n    adapter = ExchangeRegistry.get_adapter(\"binance_spot\")\n    feed = CandlesFeed(\n        adapter=adapter,\n        trading_pair=\"BTC-USDT\",\n        interval=\"1h\",\n        max_records=168  # Last 7 days of hourly data\n    )\n\n    await feed.start()\n\n    # Wait for data\n    while not feed.ready:\n        await asyncio.sleep(1)\n\n    # Get the data\n    df = feed.get_candles_df()\n\n    # Convert timestamp to datetime\n    df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')\n    df.set_index('datetime', inplace=True)\n\n    # Calculate some indicators\n    df['sma_20'] = df['close'].rolling(window=20).mean()\n    df['ema_50'] = df['close'].ewm(span=50, adjust=False).mean()\n\n    # Plot the data\n    plt.figure(figsize=(12, 6))\n    plt.plot(df.index, df['close'], label='Close Price')\n    plt.plot(df.index, df['sma_20'], label='20-period SMA')\n    plt.plot(df.index, df['ema_50'], label='50-period EMA')\n    plt.legend()\n    plt.title('BTC-USDT Price with Moving Averages')\n    plt.savefig('btc_analysis.png')\n\n    # Stop the feed\n    await feed.stop()\n</code></pre>"},{"location":"getting_started/quick_start/#working-with-different-strategies","title":"Working with Different Strategies","text":"<p>The framework automatically selects the best strategy (WebSocket or REST polling) based on exchange capabilities:</p> <pre><code>from candles_feed.core.network_strategies import WebSocketStrategy, RESTPollingStrategy\n\ndef check_strategy(candles_feed):\n    \"\"\"Check which network strategy is being used.\"\"\"\n    if isinstance(candles_feed._network_strategy, WebSocketStrategy):\n        print(\"Using WebSocket strategy for real-time updates\")\n    elif isinstance(candles_feed._network_strategy, RESTPollingStrategy):\n        print(\"Using REST polling strategy for updates\")\n    else:\n        print(f\"Using unknown strategy: {type(candles_feed._network_strategy)}\")\n</code></pre>"},{"location":"getting_started/quick_start/#error-handling","title":"Error Handling","text":"<p>Here's how to handle common errors:</p> <pre><code>try:\n    adapter = ExchangeRegistry.get_adapter(\"unknown_exchange\")\nexcept ValueError as e:\n    print(f\"Exchange not found: {e}\")\n\ntry:\n    await feed.start()\n    # Wait for data with timeout\n    start_time = time.time()\n    while not feed.ready and time.time() - start_time &lt; 30:\n        await asyncio.sleep(1)\n\n    if not feed.ready:\n        print(\"Timed out waiting for data\")\nexcept Exception as e:\n    print(f\"Error starting feed: {e}\")\nfinally:\n    await feed.stop()\n</code></pre>"},{"location":"getting_started/quick_start/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic understanding of how to use the Candles Feed framework, you can:</p> <ol> <li>Learn about the architecture and core components</li> <li>Explore the API Reference for detailed documentation</li> <li>Learn how to add support for new exchanges</li> </ol>"},{"location":"testing_resources/mock_server/","title":"Mock Server","text":"<p>The mock server component is a key part of the testing resources, providing a sophisticated simulation of exchange APIs for testing purposes. It enables you to test your code against a local server that behaves like a real exchange, without the need for internet connectivity or API keys.</p>"},{"location":"testing_resources/mock_server/#overview","title":"Overview","text":"<pre><code>graph TD\n    A[MockedCandleFeedServer] --&gt; B[HTTP Server]\n    A --&gt; C[WebSocket Server]\n    A --&gt; D[Plugin System]\n\n    D --&gt; E[ExchangePlugin]\n\n    E --&gt; F[Binance Spot Plugin]\n    E --&gt; G[Other Exchange Plugins]\n\n    B --&gt; H[REST Endpoints]\n    C --&gt; I[WS Subscriptions]\n\n    J[Network Simulation] --&gt; B\n    J --&gt; C\n\n    K[Data Generation] --&gt; H\n    K --&gt; I\n\n    style G fill:#f96</code></pre>"},{"location":"testing_resources/mock_server/#key-features","title":"Key Features","text":"<p>The mock server provides:</p> <ul> <li>Complete API Simulation: Realistic simulation of REST and WebSocket endpoints</li> <li>Dynamic Data Generation: Generates candle data with realistic price movements</li> <li>Network Condition Simulation: Simulate latency, packet loss, and server errors</li> <li>Rate Limiting: Configurable rate limits similar to real exchanges</li> <li>Plugin System: Extensible architecture for adding support for any exchange</li> </ul>"},{"location":"testing_resources/mock_server/#mockedcandlefeedserver","title":"MockedCandleFeedServer","text":"<p>The <code>MockedCandleFeedServer</code> class is the main entry point for the mock server functionality:</p> <pre><code>from candles_feed.testing_resources.mocked_candle_feed_server import MockedCandleFeedServer\nfrom candles_feed.testing_resources.mocks.core.exchange_type import ExchangeType\n\n# Create a mock server for Binance Spot\nserver = MockedCandleFeedServer(\n    exchange_type=ExchangeType.BINANCE_SPOT,\n    host=\"127.0.0.1\",\n    port=8080\n)\n\n# Configure with custom trading pairs\ncustom_pairs = [\n    (\"BTCUSDT\", \"1m\", 50000.0),  # BTC with initial price of $50,000\n    (\"ETHUSDT\", \"1m\", 3000.0),   # ETH with initial price of $3,000\n]\n\n# Start the server\nawait server.start(trading_pairs=custom_pairs)\n\n# Use the server URL in your tests\nserver_url = server.url  # e.g., \"http://127.0.0.1:8080\"\n\n# When done, stop the server\nawait server.stop()\n</code></pre>"},{"location":"testing_resources/mock_server/#network-conditions-simulation","title":"Network Conditions Simulation","text":"<p>One of the most powerful features of the mock server is the ability to simulate different network conditions:</p> <pre><code># Set challenging network conditions\nserver.set_network_conditions(\n    latency_ms=200,        # 200ms latency\n    packet_loss_rate=0.1,  # 10% packet loss\n    error_rate=0.1         # 10% error responses\n)\n\n# Reset to normal conditions\nserver.set_network_conditions(\n    latency_ms=0,\n    packet_loss_rate=0.0,\n    error_rate=0.0\n)\n</code></pre>"},{"location":"testing_resources/mock_server/#rate-limiting","title":"Rate Limiting","text":"<p>The mock server can simulate rate limiting behavior:</p> <pre><code># Set custom rate limits\nserver.set_rate_limits(\n    rest_limit=120,       # 120 requests per minute\n    rest_period_ms=60000, # 1-minute period\n    ws_limit=5,           # 5 messages per second\n    ws_burst=10           # Allow bursts of up to 10 messages\n)\n</code></pre>"},{"location":"testing_resources/mock_server/#usage-in-tests","title":"Usage in Tests","text":""},{"location":"testing_resources/mock_server/#integration-testing","title":"Integration Testing","text":"<pre><code>import pytest\nfrom candles_feed.core.candles_feed import CandlesFeed\n\nclass TestCandlesFeedIntegration:\n    @pytest.fixture\n    async def mock_server(self):\n        \"\"\"Create a standalone mock server for testing.\"\"\"\n        server = MockedCandleFeedServer(\n            exchange_type=ExchangeType.BINANCE_SPOT,\n            host=\"127.0.0.1\"\n        )\n        await server.start()\n        yield server\n        await server.stop()\n\n    @pytest.mark.asyncio\n    async def test_rest_strategy_integration(self, mock_server):\n        \"\"\"Test CandlesFeed with REST polling strategy.\"\"\"\n        # Create feed for testing\n        feed = CandlesFeed(\n            exchange=\"binance_spot\",\n            trading_pair=\"BTC-USDT\",\n            interval=\"1m\"\n        )\n\n        # Override adapter REST URL to point to our mock server\n        feed._adapter.get_rest_url = lambda: f\"{mock_server.url}/api/v3/klines\"\n\n        try:\n            # Start the feed with REST polling strategy\n            await feed.start(strategy=\"polling\")\n\n            # Verify candles were retrieved\n            candles = feed.get_candles()\n            assert len(candles) &gt; 0\n\n        finally:\n            # Stop the feed\n            await feed.stop()\n</code></pre>"},{"location":"testing_resources/mock_server/#testing-error-handling","title":"Testing Error Handling","text":"<pre><code>@pytest.mark.asyncio\nasync def test_error_handling(mock_server):\n    \"\"\"Test system's response to network issues.\"\"\"\n    # Set error conditions\n    mock_server.set_network_conditions(\n        latency_ms=100,\n        packet_loss_rate=0.2,\n        error_rate=0.2\n    )\n\n    # Create feed and test\n    feed = CandlesFeed(\n        exchange=\"binance_spot\",\n        trading_pair=\"BTC-USDT\",\n        interval=\"1m\"\n    )\n\n    # Override adapter URLs to point to our mock server\n    feed._adapter.get_rest_url = lambda: f\"{mock_server.url}/api/v3/klines\"\n    feed._adapter.get_ws_url = lambda: f\"ws://{mock_server.host}:{mock_server.port}/ws\"\n\n    # Test with error conditions\n    # ... (Your test code here)\n\n    # Reset conditions for recovery testing\n    mock_server.set_network_conditions(\n        latency_ms=0,\n        packet_loss_rate=0.0,\n        error_rate=0.0\n    )\n\n    # Verify recovery\n    # ... (Your verification code here)\n</code></pre>"},{"location":"testing_resources/mock_server/#adding-support-for-new-exchanges","title":"Adding Support for New Exchanges","text":"<p>To add support for a new exchange in the mock server, you need to create a plugin that implements the exchange's API behavior:</p> <pre><code>from candles_feed.testing_resources.mocks.core.exchange_plugin import ExchangePlugin\nfrom candles_feed.testing_resources.mocks.core.exchange_type import ExchangeType\n\nclass NewExchangePlugin(ExchangePlugin):\n    def __init__(self, exchange_type: ExchangeType):\n        super().__init__(exchange_type)\n\n    @property\n    def rest_routes(self):\n        return {\n            '/api/candles': ('GET', 'handle_klines'),\n            # ... other routes\n        }\n\n    async def handle_klines(self, request):\n        \"\"\"Handle klines request for the new exchange.\"\"\"\n        # Parse request parameters\n        # Generate response data\n        # Return formatted response\n\n    @property\n    def ws_message_handlers(self):\n        return {\n            'subscribe': self.handle_subscribe,\n            # ... other message types\n        }\n\n    async def handle_subscribe(self, websocket, message):\n        \"\"\"Handle subscription request for the new exchange.\"\"\"\n        # Parse subscription request\n        # Set up subscription\n        # Send confirmation\n</code></pre>"},{"location":"testing_resources/mock_server/#current-limitations","title":"Current Limitations","text":"<ol> <li>Realistic Data Patterns: While the mock server generates plausible price movements, they don't fully simulate real market behavior like volatility clustering or specific patterns.</li> <li>WebSocket Connection Limits: The server does not currently enforce WebSocket connection limits per client.</li> <li>Advanced Authentication: Only basic authentication schemes are implemented.</li> </ol>"},{"location":"testing_resources/mock_server/#future-enhancements","title":"Future Enhancements","text":"<ol> <li>More exchange plugins</li> <li>Advanced market simulation models</li> <li>Improved error simulation options</li> <li>Recording and playback of real exchange data</li> </ol>"},{"location":"testing_resources/mock_server/#see-also","title":"See Also","text":"<ul> <li>Candle Data Factory - For generating test data</li> <li>Exchange Simulation - For more details on the simulation framework</li> <li>Usage Examples - For practical examples of using the mock server</li> </ul>"},{"location":"testing_resources/overview/","title":"Testing Resources Overview","text":"<p>The candles-feed package provides a comprehensive testing framework that enables thorough testing of exchange integrations without requiring access to real exchange APIs. This framework is particularly valuable for:</p> <ul> <li>Unit Testing: Testing adapter implementations without network dependencies</li> <li>Integration Testing: Testing the interaction between components</li> <li>End-to-End Testing: Testing complete workflows</li> <li>Error Handling: Testing system resilience under various error conditions</li> </ul>"},{"location":"testing_resources/overview/#key-components","title":"Key Components","text":"<pre><code>graph TD\n    A[Testing Resources] --&gt; B[Mock Server]\n    A --&gt; C[Candle Data Factory]\n    A --&gt; D[Exchange Simulation]\n    A --&gt; E[Usage Examples]\n\n    B --&gt; F[MockedCandleFeedServer]\n\n    D --&gt; G[Exchange Plugins]\n    D --&gt; H[Network Conditions]\n    D --&gt; I[Data Generation]\n\n    G --&gt; J[Binance Spot Plugin]\n    G --&gt; K[Other Exchange Plugins]\n\n    C --&gt; L[Random Data Generation]\n    C --&gt; M[Realistic Price Movement]\n\n    E --&gt; N[Example Scripts]\n    E --&gt; O[Test Cases]\n\n    style K fill:#f96</code></pre>"},{"location":"testing_resources/overview/#mock-server","title":"Mock Server","text":"<p>The mock server component provides a complete simulation of exchange APIs, including:</p> <ul> <li>HTTP server for REST API endpoints</li> <li>WebSocket server for real-time data</li> <li>Rate limiting behavior similar to real exchanges</li> <li>Customizable error conditions</li> </ul>"},{"location":"testing_resources/overview/#candle-data-factory","title":"Candle Data Factory","text":"<p>This component provides tools for generating realistic candle data:</p> <ul> <li>Random data generation with configurable parameters</li> <li>Price movement models based on real market behavior</li> <li>Time series generation with appropriate timestamps</li> <li>Custom data patterns for specific test scenarios</li> </ul>"},{"location":"testing_resources/overview/#exchange-simulation","title":"Exchange Simulation","text":"<p>The exchange simulation framework provides:</p> <ul> <li>Realistic exchange behavior simulation</li> <li>Support for multiple exchange types through plugins</li> <li>Network condition simulation (latency, errors, etc.)</li> <li>Configurable market behavior</li> </ul>"},{"location":"testing_resources/overview/#usage-examples","title":"Usage Examples","text":"<p>The testing resources include comprehensive examples demonstrating:</p> <ul> <li>Setting up mock servers for testing</li> <li>Generating and working with test data</li> <li>Writing effective tests using the framework</li> <li>Advanced testing scenarios</li> </ul>"},{"location":"testing_resources/overview/#benefits-for-users","title":"Benefits for Users","text":"<ol> <li>Reproducible Tests: Create consistent test environments without external dependencies</li> <li>Faster Testing: Run tests without network latency or rate limiting</li> <li>Complete Coverage: Test error cases that are difficult to reproduce with real exchanges</li> <li>Development Without Exchange Access: Develop and test exchange integrations without API keys</li> </ol>"},{"location":"testing_resources/overview/#target-audience","title":"Target Audience","text":"<p>This testing framework is designed for:</p> <ol> <li>Framework Maintainers: For testing the core candles-feed components</li> <li>Adapter Developers: For developing and testing new exchange adapters</li> <li>Client Application Developers: For testing applications built with candles-feed</li> </ol>"},{"location":"testing_resources/overview/#getting-started","title":"Getting Started","text":"<p>To get started with the testing resources:</p> <ol> <li>See the Mock Server documentation for setting up a test server</li> <li>Use the Candle Data Factory to generate test data</li> <li>Review the Exchange Simulation guide for detailed simulation options</li> <li>Check out the Usage Examples for practical demonstrations</li> </ol> <p>For detailed API documentation, see the API Reference section.</p>"}]}