"""
Cython build hook for Hatch

This script runs during the build process to compile any Python modules 
that have functions decorated with @cython. This replaces the need for
separate CMake configuration files.
"""

import glob
import os
import subprocess
import sys
from pathlib import Path

def find_cython_modules(directory):
    """Find Python files with @cython decorators"""
    cython_modules = []
    for py_file in Path(directory).glob("**/*.py"):
        # Skip __init__.py files
        if py_file.name == "__init__.py":
            continue
            
        try:
            with open(py_file, "r", encoding="utf-8") as f:
                content = f.read()
                if "@cython" in content:
                    cython_modules.append(str(py_file))
        except Exception:
            continue
            
    return cython_modules

def compile_cython_modules(modules, build_dir):
    """Compile Cython modules"""
    if not modules:
        print("No Cython modules found to compile")
        return
        
    print(f"Compiling {len(modules)} Cython modules...")
    
    # Make sure Cython is installed
    try:
        import Cython
        from Cython.Build import cythonize
        import numpy as np
    except ImportError:
        print("Cython or NumPy not found, skipping Cython compilation")
        return
        
    # Compile each module
    for module in modules:
        try:
            # Convert .py to .pyx
            module_path = Path(module)
            pyx_file = module_path.with_suffix(".pyx")
            
            # Copy content from .py to .pyx
            with open(module_path, "r", encoding="utf-8") as src:
                content = src.read()
                
            with open(pyx_file, "w", encoding="utf-8") as dst:
                dst.write(content)
                
            # Compile with Cython
            cmd = [
                sys.executable, "-m", "cython", 
                "--3str", "-a", str(pyx_file)
            ]
            subprocess.run(cmd, check=True)
            
            print(f"Successfully compiled {module_path.name}")
            
        except Exception as e:
            print(f"Error compiling {module}: {str(e)}")

def initialize(version, build_data):
    """Initialize hook"""
    return {}
            
def finalize(version, build_data, artifact_path):
    """Finalize hook"""
    return {}
    
def clean(versions, build_data):
    """Clean hook"""
    # Remove generated Cython files
    candles_feed = build_data.get("wheel", {}).get("packages", ["candles_feed"])[0]
    
    # Find and remove .c, .cpp and .so files generated by Cython
    extensions = [".c", ".cpp", ".so", ".pyd", ".html"]
    for ext in extensions:
        for path in glob.glob(f"{candles_feed}/**/*{ext}", recursive=True):
            try:
                os.remove(path)
                print(f"Removed: {path}")
            except Exception:
                pass
                
    # Remove .pyx files (converted from .py)
    for path in glob.glob(f"{candles_feed}/**/*.pyx", recursive=True):
        try:
            os.remove(path)
            print(f"Removed: {path}")
        except Exception:
            pass
    
    return {}

def build(version, build_data, artifact_path):
    """Build hook"""
    # Get package name from build data
    candles_feed = build_data.get("wheel", {}).get("packages", ["candles_feed"])[0]
    
    # Find Cython modules
    cython_modules = find_cython_modules(candles_feed)
    
    # Create build directory if it doesn't exist
    build_dir = Path("build") / "cython"
    build_dir.mkdir(parents=True, exist_ok=True)
    
    # Compile Cython modules
    compile_cython_modules(cython_modules, build_dir)
    
    return {}